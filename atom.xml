<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Never_yu&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9bef1a6653a58edaedf8e7be2f181709</icon>
  <subtitle>认真的人才有资格开玩笑</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://neveryu.github.io/"/>
  <updated>2025-04-04T13:51:08.861Z</updated>
  <id>https://neveryu.github.io/</id>
  
  <author>
    <name>Never_yu</name>
    <email>never_yu@foxmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Web页面中直接播放rtsp格式视频流</title>
    <link href="https://neveryu.github.io/2023/about-rtsp2web/"/>
    <id>https://neveryu.github.io/2023/about-rtsp2web/</id>
    <published>2023-06-19T22:25:24.000Z</published>
    <updated>2025-04-04T13:51:08.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我之前研究在 web 中直接播放 rtsp 视频流时，研究了非常多的方案和技术手段，发现了要解决这个问题的核心：</p><p id="div-border-left-blue">要想在 web 中实时播放 rtsp 视频流：借助服务端拉流转码将是必要的操作。</p><p>我用 <code>node.js</code> 实现了拉流转码的功能，并将其打包成 <a href="https://www.npmjs.com/package/rtsp2web" target="_blank" rel="external">rtsp2web</a> 发布到了 <a href="https://www.npmjs.com/package/rtsp2web" target="_blank" rel="external">npm</a> 上；这样，在前端就可以直接使用播放器来进行播放了。<br><a href="https://www.npmjs.com/package/rtsp2web" target="_blank" rel="external">rtsp2web</a> 使用方便、快捷、高效，对前端开发人员来说，非常的友好。详细使用教程如下：</p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>rtsp2web</code> 是一个依赖 <code>ffmpeg</code>，能实时将传入的 rtsp 视频流转码成图像数据并通过 ws 推送到前端的智能工具包。<br>前端页面借助 jsmpeg.js 或者 flv.js 等播放工具就可以很轻松的实现播放啦~<br>rtsp2web 还有以下特点：</p><ul><li>高性能，配置丰富，满足多种复杂业务场景的使用需求；</li><li>并发，支持同时播放多路视频；</li><li>合并同源，多个视频窗口同时播放同一个 rtsp 视频源时，只会创建一个转码进程，不会创建多个；</li><li>智能释放资源，智能检测当前没有在使用的转码进程，将其关闭，并释放电脑资源；</li><li>上手简单，提供的示例代码完整可运行，无需繁琐复杂的技术负担，直接运行代码，快速解决视频流播放的问题；</li><li>延时非常低，视频流稳定，几乎是实时的，满足任何需求；不花钱，采用开源框架，无商业风险；</li><li>别的收费平台，需要暴露 RTSP 视频流链接给收费平台，rtsp2web 无需您提供 RTSP 视频流，您的保密和安全牢牢掌握在您手中；</li><li>高效兼容，大多数 nvr 或 ipc 或摄像头平台都支持输出 RTSP 视频流，rtsp2web 把 RTSP 视频流转换到页面可播放，减少对接工作，无论您是什么摄像头；</li><li>支持前端使用 jsmpeg.js、flv.js 等播放器，满足不同技术栈团队使用；</li><li>删繁就简，无需插件就可在浏览器显示视频画面，兼容各大浏览器厂商；</li><li>省时省力，同一页面可以播放不同厂家的视频，无需任何额外操作，轻松支持多路视频同时播放；</li><li>可以在公网上部署使用，但也可能因为你们公司网络的设置原因，你会面临一点小问题：还要学习网络穿透打洞，服务器部署能力，流量消耗，wss 等。</li></ul><h1 id="支持的视频厂商"><a href="#支持的视频厂商" class="headerlink" title="支持的视频厂商"></a>支持的视频厂商</h1><p>海康、海康 NVR、大华平台、萤石、宇视、中天信科达、东方网力、天地伟业等所有摄像头，视频厂商。</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>使用 <code>rtsp2web</code> 是很简单的，你只需：</p><h2 id="一、准备-FFmpeg"><a href="#一、准备-FFmpeg" class="headerlink" title="一、准备 FFmpeg"></a>一、准备 FFmpeg</h2><p><a href="https://ffmpeg.org/download.html" target="_blank" rel="external">FFmpeg</a> 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。可以轻易地实现多种视频格式之间的相互转换。所以：<strong>确保在你要运行 rtsp2web 的机器上已经安装了 FFmpeg。</strong></p><blockquote><p>验证 FFmpeg 是否安装成功： <em>重新打开一个命令行窗口，输入：<code>ffmpeg -version</code> ，如果有相关信息输出，则证明 FFmpeg 的安装是 OK 的。</em></p></blockquote><h2 id="二、运行-rtsp2web"><a href="#二、运行-rtsp2web" class="headerlink" title="二、运行 rtsp2web"></a>二、运行 rtsp2web</h2><p><code>rtsp2web</code> 是一个 <code>node.js</code> 包，你可以创建一个新的项目引入它，这个操作很简单，然后运行它即可；也可以把 <code>rtps2web</code> 集成到已有的项目中，随项目来运行启动（前提是如果你知道怎么做的话）；</p><p><strong>这里以创建一个新项目运行它为例：（<em>这是最简单的做法</em>）</strong></p><p>2.1、创建一个新的文件夹（假如文件夹名叫：<code>rtsp_server</code>），<em>注意 ⚠️：文件夹名称不能是 rtsp2web，这是 npm 的规则</em>。<br>2.2、进入项目文件夹： <code>cd rtsp_server</code>。<br>2.3、然后安装 <code>rtsp2web</code> 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i rtsp2web</span><br></pre></td></tr></table></figure><p>2.4、在 <code>rtsp_server</code> 文件夹中创建入口 js 文件（例如：<code>main.js</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> RTSP2web = <span class="built_in">require</span>(<span class="string">"rtsp2web"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端长连接占据的端口号；你也可以不传，默认是：9999</span></span><br><span class="line"><span class="keyword">let</span> port = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个RTSP2web服务实例出来</span></span><br><span class="line"><span class="keyword">new</span> RTSP2web(&#123;</span><br><span class="line">  port,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行命令：<code>node index.js</code> 启动视频流转码服务，即可。到此，你的视频转码服务就已经运行起来了。</p><blockquote><p>当然，你也可以选择你习惯的进程管理工具来启动它。如：pm2 之类的工具。</p></blockquote><p><b>参数说明（在 new RTSP2web 时，可配置的参数如下）</b></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">解释说明</th></tr></thead><tbody><tr><td style="text-align:center">port</td><td style="text-align:center">转码推流服务占用的端口号；（type：Number）<br>可以不传；默认值：9999</td></tr><tr><td style="text-align:center">path</td><td style="text-align:center">FFmpeg 命令在你机器上的启动名称，(type: String) <br> 一般情况下不传；默认值：’ffmpeg’</td></tr><tr><td style="text-align:center">audio</td><td style="text-align:center">默认不传，有声音；默认值：true；即：输出音频。<br>如果想禁止输出音频，可以配置 audio: false</td></tr><tr><td style="text-align:center">freeTime</td><td style="text-align:center">任一视频流空闲(未被使用)时间超过这个值，就会停止该视频流的转码，释放机器资源（type: Number；单位：秒） <br> 一般情况下可不传；默认值：20</td></tr><tr><td style="text-align:center">checkTime</td><td style="text-align:center">检测视频空闲的时间间隔（type: Number；单位：秒） <br> 一般情况下可不传；默认值：10</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">视频质量；取值范围：0-1000；数字越小，视频越清晰，带宽消耗越大<br> 默认值：8；</td></tr><tr><td style="text-align:center">transportType</td><td style="text-align:center">设置 RTSP 传输协议，(type: String)，默认值：无<br>可选值：[<code>&#39;tcp&#39;</code>, <code>&#39;udp&#39;</code>, <code>&#39;udp_multicast&#39;</code>, <code>&#39;http&#39;</code>, <code>&#39;https&#39;</code>]中选一个<br>ps: 这里默认值是无，也就是 rtsp2web 会自动选择一种传输协议；但是，并不能保证一定成功，这个时候，rtsp2web 日志会打印错误信息或者长时间的等待，这个时候就需要你手动来配置这个参数了，<code>&#39;tcp&#39;</code>、<code>&#39;udp&#39;</code> 是最常见的选择；详情可以参阅文档最后的【常见问题解决办法】</td></tr><tr><td style="text-align:center">webplayer</td><td style="text-align:center">设置前端播放器（视频流转码器），默认不传，默认值：<code>&#39;jsmpeg&#39;</code><br>可选值：[<code>&#39;jsmpeg&#39;</code>, <code>&#39;flv&#39;</code>]中选一个；如果设置为 <code>flv</code>，那么前端页面请使用 <code>flv.js</code> 播放器，详情请参考下面 <code>flv.js</code> 小节了解详细的使用方法</td></tr><tr><td style="text-align:center">wss</td><td style="text-align:center">配置 wss；配置格式如下：<br> <code>wss: {key: &#39;keyPath&#39;, cert: &#39;certPath&#39;}</code> <br>如果你是 pfx 的证书，那么配置格式如下：<br><code>wss: {pfx: &#39;pfxPath&#39;, passphrase: &#39;passphrasePath&#39;}</code><br>如果你想使用<code>wss</code>的话请配置这个选项，否则不要使用这个配置。</td></tr></tbody></table><h2 id="三、在页面中播放视频"><a href="#三、在页面中播放视频" class="headerlink" title="三、在页面中播放视频"></a>三、在页面中播放视频</h2><p>不管你的前端是用原生的 html 还是使用的 React、Vue、Angular 等框架，操作起来都非常简单的。你只需 3 步：<br>3.1、在你的页面中需要引入 jsmpeg.js<br>3.2、创建一个 canvas 容器，用来播放视频窗口<br>3.3、new 一个视频源播放实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rtsp = <span class="string">"rtmp://mobliestream.c3tv.com:554/live/goodtv.sdp"</span>;</span><br><span class="line"><span class="comment">// 将rtsp视频流地址进行btoa处理一下</span></span><br><span class="line"><span class="keyword">new</span> JSMpeg.Player(<span class="string">"ws://localhost:9999/rtsp?url="</span> + btoa(rtsp), &#123;</span><br><span class="line">  canvas: <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一个完整的示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no,viewport-fit=cover"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://jsmpeg.com/jsmpeg.min.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>播放rtsp<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方式一：不给定宽度和高度，视频将会和视频源大小保持一致--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 方式二: 只给定宽度或者高度，另外一个值将会自适应；整体比例与原视频一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas-2"</span> <span class="attr">style</span>=<span class="string">"width: 400px"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 方式三: 可以自定义视频播放窗口的宽度和高度，会铺满，比例可能与原视频不一致了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas-3"</span> <span class="attr">style</span>=<span class="string">"width: 400px; height: 400px"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 方式四：使用div + class="jsmpeg" + data-url的方式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这种方式虽然设置了固定的宽高，但是视频还是会选择安宽度来自适应，比例与原视频保持一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"jsmpeg"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">"canvas-4"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">"width: 400px; height: 400px; border: 1px solid red"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">data-url</span>=<span class="string">"ws://localhost:9999/rtsp?url=cnRzcDovL3dvd3phZWMyZGVtby5zdHJlYW1sb2NrLm5ldC92b2QvbXA0OkJpZ0J1Y2tCdW5ueV8xMTVrLm1wNA=="</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> rtsp1 = <span class="string">"rtmp://mobliestream.c3tv.com:554/live/goodtv.sdp"</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 将rtsp视频流地址进行btoa处理一下</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> JSMpeg.Player(<span class="string">"ws://localhost:9999/rtsp?url="</span> + btoa(rtsp1), &#123;</span></span><br><span class="line"><span class="javascript">        canvas: <span class="built_in">document</span>.getElementById(<span class="string">"canvas-1"</span>),</span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="javascript">      <span class="comment">// 将rtsp视频流地址进行btoa处理一下，还可以加一点参数，如下</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> JSMpeg.Player(</span></span><br><span class="line"><span class="javascript">        <span class="string">"ws://localhost:9999/rtsp?url="</span> +</span></span><br><span class="line">          btoa(rtsp1) +</span><br><span class="line"><span class="javascript">          <span class="string">"&amp;brightness=0.2&amp;saturation=1.8"</span>,</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          canvas: <span class="built_in">document</span>.getElementById(<span class="string">"canvas-2"</span>),</span></span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>【说明】：<code>JSMpeg.Player</code> 第一个参数是拼接转码链接 <code>&#39;ws://localhost:9999/rtsp?url=&#39; + btoa(rtsp)</code>； 第二个参数是一个对象，对象里面属性包含 canvas。关于第二个参数里面的其他属性，详情可以参考 <a href="https://github.com/phoboslab/jsmpeg" target="_blank" rel="external">jsmpeg 官方文档</a></p></blockquote><h3 id="html-中的参数说明"><a href="#html-中的参数说明" class="headerlink" title="html 中的参数说明"></a>html 中的参数说明</h3><p id="div-border-left-blue">如上面的例子所示：在调用 <code>new JSMpeg.Player()</code> 时，第一个参数是接口地址拼接上 rtsp 地址，其实我们还可以使用 url 传参的方式传递更多的高阶参数。</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">解释说明</th></tr></thead><tbody><tr><td style="text-align:center">-s</td><td style="text-align:center">视频分辨率大小，不传即表示与源视频大小一致<br> 传值示例： 1920x1080、1280x720、640x360 <br> 降低分辨率会降低清晰度</td></tr><tr><td style="text-align:center">-b:v</td><td style="text-align:center">释义：码率，默认可以不设置，那就是使用源码率<br>传值示例：2000k、100k、1k<br>码率调小，这样其实也间接让文件变小了<br>码率调小，画质有可能会降低</td></tr><tr><td style="text-align:center">scale</td><td style="text-align:center">缩放；间接的，也能调整视频的分辨率；<br> 默认值： -1:-1；即与视频源大小保持一致；<br>功能与 -s 参数相似；但是可以只传一个宽度或者高度，另一个参数用 -1 表示<br>如： 1280:-1、-1:360，视频将会自适应现实<br>降低分辨率会降低清晰度</td></tr><tr><td style="text-align:center">vcodec</td><td style="text-align:center">释义：视频编解码方式；<br>请确保你了解该参数的意义，默认可以不传</td></tr><tr><td style="text-align:center">contrast</td><td style="text-align:center">释义：对比度，亮的地方更亮，暗的地方更暗。<br>取值范围[-100.0, 100.0]，默认值为 0。建议不调整，或者在[-2.0, 2.0]范围内进行小的调整</td></tr><tr><td style="text-align:center">brightness</td><td style="text-align:center">释义：亮度，如果觉得视频有点暗，可以进行小的调整。<br>取值范围： [-1.0, 1.0]，默认值为 0。</td></tr><tr><td style="text-align:center">saturation</td><td style="text-align:center">释义：饱和度，也就是说色彩更鲜艳，绿色更绿，蓝色更蓝…；<br>取值范围：[0, 3.0]，默认值为 1。</td></tr><tr><td style="text-align:center">gamma</td><td style="text-align:center">释义：关于显示器/视频的一个专业参数；<br>取值范围：0.1-10.0，默认值为 1。<br>这个参数很专业，建议不传，不修改。</td></tr></tbody></table><p>一个传了很多参数的例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> JSMpeg.Player(</span><br><span class="line">  <span class="string">"ws://localhost:9999/rtsp?url="</span> +</span><br><span class="line">    btoa(rtsp1) +</span><br><span class="line">    <span class="string">"&amp;scale=640:-1&amp;-b:v=1k&amp;brightness=0.2&amp;saturation=1.8"</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    canvas: <span class="built_in">document</span>.getElementById(<span class="string">"canvas-2"</span>),</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p id="div-border-left-blue">更多详细操作可以参考例子：<a href="https://github.com/Neveryu/rtsp2web/tree/master/example" target="_blank" rel="external">https://github.com/Neveryu/rtsp2web/tree/master/example</a></p><p id="div-border-left-yellow">ps: 目前使用 rtsp2web 的用户中，绝大多数情况下都能正常使用；极少数用户会遇到一点问题，所以文档最后面有【常见问题解决办法】，必要时可以看看</p><h1 id="去水印"><a href="#去水印" class="headerlink" title="去水印"></a>去水印</h1><p>正确的去除水印能减小 <code>FFmpeg</code> 性能开销，有效提高 <code>FFmpeg</code> 运行效率，提升视频播放质量，减小机器内存占用，可支撑更多的视频；<br>如何去除水印，<a href="https://neveryu.blog.csdn.net/article/details/124124137" target="_blank" rel="external">联系我</a>；wechat： miracle421354532</p><h1 id="声音"><a href="#声音" class="headerlink" title="声音"></a>声音</h1><p>rtsp2web 默认自动转码音频并输出，你也可以根据配置设置，选择禁止音频输出。</p><p id="div-border-top-yellow"><i>在浏览器中，自动播放声音是突兀的；根据浏览器规则，需要用户在页面任意地方进行任意的点击操作，就有声音了；如果配置了输出音频，为了播放声音，可以点击一下页面任意地方。</i></p><h1 id="支持-flv-js"><a href="#支持-flv-js" class="headerlink" title="支持 flv.js"></a>支持 flv.js</h1><p><code>flv.js</code> 也是现在主流的播放器之一，而且 <code>flv.js</code> 播放器，默认就有进度条、在线回放、全屏、画中画、倍速播放等功能，有需要的可以选择 <code>flv.js</code>。<br>如果你的前端代码中使用的是 <code>flv.js</code> 或者你想在前端代码中使用 <code>flv.js</code> 来播放视频的话，你可以按如下操作：</p><p>1、在创建 <code>rtsp2web</code> 时，增加配置项 <code>webplayer: &#39;flv&#39;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> RTSP2web = <span class="built_in">require</span>(<span class="string">"rtsp2web"</span>);</span><br><span class="line"><span class="comment">// 服务端长连接占据的端口号</span></span><br><span class="line"><span class="keyword">let</span> port = <span class="number">9999</span>;</span><br><span class="line"><span class="keyword">new</span> RTSP2web(&#123;</span><br><span class="line">  port,</span><br><span class="line">  q: <span class="number">20</span>,</span><br><span class="line">  webplayer: <span class="string">"flv"</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2、在前端代码中引入 <code>flv.js</code>，并创建一个 <code>video</code> 标签节点，然后在 <code>js</code> 中初始化 <code>flv</code> 并播放。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./flv.min.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">video</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"flv-1"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">height</span>=<span class="string">"500"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">muted</span></span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">"border: thin solid green"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">controls</span></span></span><br><span class="line"><span class="tag">  <span class="attr">loop</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">"flvjs 是否支持："</span>, flvjs.isSupported());</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> rtsp1 = <span class="string">"rtmp://mobliestream.c3tv.com:554/live/goodtv.sdp"</span>;</span></span><br><span class="line">  if (flvjs.isSupported()) &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> videoElement = <span class="built_in">document</span>.getElementById(<span class="string">"flv-1"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> flvPlayer = flvjs.createPlayer(&#123;</span></span><br><span class="line"><span class="javascript">      isLive: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      type: <span class="string">"flv"</span>,</span></span><br><span class="line"><span class="javascript">      url: <span class="string">"ws://localhost:9999/rtsp?url="</span> + btoa(rtsp1),</span></span><br><span class="line"><span class="javascript">      enableWorker: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      enableStashBuffer: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">      stashInitialSize: <span class="number">128</span>, <span class="comment">// 减少首桢显示等待时长</span></span></span><br><span class="line">    &#125;);</span><br><span class="line">    flvPlayer.attachMediaElement(videoElement);</span><br><span class="line"><span class="javascript">    <span class="keyword">try</span> &#123;</span></span><br><span class="line">      flvPlayer.load();</span><br><span class="line">      flvPlayer.play();</span><br><span class="line"><span class="javascript">      <span class="comment">// flvPlayer.pause()</span></span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">catch</span> (err) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// not do something</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于使用 <code>flv.js</code> 的详细情况可以参考例子中的 <code>index-flv.html</code> 文件：<a href="https://github.com/Neveryu/rtsp2web/tree/master/example/index-flv.html" target="_blank" rel="external">https://github.com/Neveryu/rtsp2web/tree/master/example/index-flv.html</a><br>有任何不明白的，及时与我联系：<a href="https://neveryu.blog.csdn.net/article/details/124124137" target="_blank" rel="external">联系我</a>；wechat： miracle421354532</p><h1 id="常见问题解决办法"><a href="#常见问题解决办法" class="headerlink" title="常见问题解决办法"></a>常见问题解决办法</h1><h2 id="一、某某模式转换失败-或者-进程退出，请检查-ffmpeg-参数…-或者-长时间等待画面…-或者-其他等等问题"><a href="#一、某某模式转换失败-或者-进程退出，请检查-ffmpeg-参数…-或者-长时间等待画面…-或者-其他等等问题" class="headerlink" title="一、某某模式转换失败 [或者] 进程退出，请检查 ffmpeg 参数… [或者] 长时间等待画面… [或者] 其他等等问题"></a>一、某某模式转换失败 [或者] 进程退出，请检查 ffmpeg 参数… [或者] 长时间等待画面… [或者] 其他等等问题</h2><p>如果出现了这之类的提示，大多数情况下，你可能需要尝试配置 <code>transportType</code> 为其他值试试，<code>&#39;tcp&#39;</code>, <code>&#39;udp&#39;</code>是最常见的选择。</p><p id="div-border-left-purple"><i>PS: 在正常的操作下遇到视频流无法播放，或者 <code>rtsp2web</code> 提示错误信息的情况下，优先选择使用这条解决办法来尝试解决问题。</i></p><h2 id="二、ffmpeg-进程关闭了，code：3221225477"><a href="#二、ffmpeg-进程关闭了，code：3221225477" class="headerlink" title="二、ffmpeg 进程关闭了，code：3221225477"></a>二、ffmpeg 进程关闭了，code：3221225477</h2><blockquote><p>如果出现了 <code>3221225477</code>；这是 NodeJS 内核反馈的[违反了访问规定]的问题，一般这个问题只发生在 <code>windows</code> 平台上。据我所知，这似乎是与 Windows 访问冲突相关的错误。可以尝试的操作有：</p></blockquote><ul><li>1、执行 <code>npm cache verify</code>，然后再试试；</li><li>2、清除 <code>npm</code> 缓存：<code>npm cache clean --force</code>，再试试；</li><li>3、升级更新 <code>nodejs</code>，安装稳定版，再试试；</li><li>4、<code>rm -rf node_modules</code>，<code>delete package-lock.json</code>，重新安装，再试试；</li><li>5、切换合适的 <code>node</code> 版本可解决；切换当前 <code>node</code> 版本可解决这个问题。</li><li>6、也可以参考【办法一】来尝试解决这类问题；</li></ul><h2 id="三、转换失败，请尝试改变-transportType-的值，然后重试。"><a href="#三、转换失败，请尝试改变-transportType-的值，然后重试。" class="headerlink" title="三、转换失败，请尝试改变 transportType 的值，然后重试。"></a>三、转换失败，请尝试改变 transportType 的值，然后重试。</h2><blockquote><p>你可以尝试配置 <code>transportType</code> 为其他值试试，<code>&#39;tcp&#39;</code>, <code>&#39;udp&#39;</code>是最常见的选择。</p></blockquote><h2 id="四、其他问题随时沟通"><a href="#四、其他问题随时沟通" class="headerlink" title="四、其他问题随时沟通"></a>四、其他问题随时沟通</h2><p>wechat： miracle421354532</p><h1 id="以下客户使用了-rtsp2web"><a href="#以下客户使用了-rtsp2web" class="headerlink" title="以下客户使用了 rtsp2web"></a>以下客户使用了 rtsp2web</h1><p>广州天河区智慧交通、江苏石油化工油罐工厂、江苏镇江石化、武汉丽岛物业、武汉恒阳化工厂、苏州工业园区等<br>还有一些个人、企业用户等。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>经过反复测试，验证，调试，以及用户的使用和反馈；rtsp2web 可以解决所有的视频流播放问题，如果你在使用的过程中，遇到了些问题，请仔细查看本文档并进行测试，验证。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我之前研究在 web 中直接播放 rtsp 视频流时，研究了非常多的方案和技术手段，发现了要解决这个问题的核心：&lt;/p&gt;
&lt;p id=&quot;div-border-left-blue&quot;&gt;要想在 web 中实时播放 rtsp 视频流：借助服务端拉流转码将是必要的操作。&lt;/p&gt;

&lt;p&gt;我用 &lt;code&gt;node.js&lt;/code&gt; 实现了拉流转码的功能，并将其打包成 &lt;a href=&quot;https://www.npmjs.com/package/rtsp2web&quot;&gt;rtsp2web&lt;/a&gt; 发布到了 &lt;a href=&quot;https://www.npmjs.com/package/rtsp2web&quot;&gt;npm&lt;/a&gt; 上；这样，在前端就可以直接使用播放器来进行播放了。&lt;br&gt;&lt;a href=&quot;https://www.npmjs.com/package/rtsp2web&quot;&gt;rtsp2web&lt;/a&gt; 使用方便、快捷、高效，对前端开发人员来说，非常的友好。详细使用教程如下：&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="rtsp" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/rtsp/"/>
    
    
      <category term="rtsp2web" scheme="https://neveryu.github.io/tags/rtsp2web/"/>
    
      <category term="ffmpeg" scheme="https://neveryu.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>何时使用 HTTPS 进行本地开发</title>
    <link href="https://neveryu.github.io/2023/when-to-use-local-https/"/>
    <id>https://neveryu.github.io/2023/when-to-use-local-https/</id>
    <published>2023-04-30T21:20:00.000Z</published>
    <updated>2023-04-04T11:40:08.391Z</updated>
    
    <content type="html"><![CDATA[<p>大多数情况下，使用 <a href="http://localhost" target="_blank" rel="external">http://localhost</a> 进行本地开发是可以的，但在某些特殊情况下除外。之前也介绍过了如何使用 HTTPS 进行本地开发。这篇文章解释了何时需要使用 HTTPS 运行本地开发站点。</p><a id="more"></a><p>另请参阅：<a href="/2023/how-to-use-local-https/">如何使用 HTTPS 进行本地开发</a>。</p><p><i>在这篇文章中，about 语句对和也是<code>localhost</code>有效的，因为它们都描述了本地计算机地址，也称为“环回地址”。此外，为简单起见，未指定端口号。<code>127.0.0.1[::1]</code> 因此，当您看到时<code>http://localhost</code>，请将其读作<code>http://localhost:{PORT}</code>或<code>http://127.0.0.1:{PORT}</code>。</i></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在本地开发时，默认使用<code>http://localhost</code>。Service Workers、Web Authentication API 等都可以使用。<strong>但是，在以下情况下，您需要使用 HTTPS 进行本地开发：</strong></p><ul><li>跨浏览器以一致的方式设置安全 cookie</li><li>调试混合内容问题</li><li>使用 HTTP/2 及更高版本</li><li>使用需要 HTTPS 的第三方库或 API</li><li>使用自定义主机名</li></ul><p id="div-border-top-blue"><i>如果您需要 HTTPS 用于上述用例之一，请查看<a href="/2023/how-to-use-local-https/">如何使用 HTTPS 进行本地开发</a>。</i></p><h1 id="为什么你的开发网站应该安全运行"><a href="#为什么你的开发网站应该安全运行" class="headerlink" title="为什么你的开发网站应该安全运行"></a>为什么你的开发网站应该安全运行</h1><p>为避免遇到意外问题，您希望本地开发网站的行为尽可能像生产网站一样。因此，如果您的生产网站使用 HTTPS，您希望您的本地开发网站<strong>表现得像 HTTPS 网站</strong>。</p><p id="div-border-top-yellow"><i>如果您的生产网站不使用 HTTPS，<a href="/2022/why-https-matters/">请将其设为优先级</a>。</i></p><h1 id="何时使用-HTTPS-进行本地开发"><a href="#何时使用-HTTPS-进行本地开发" class="headerlink" title="何时使用 HTTPS 进行本地开发"></a>何时使用 HTTPS 进行本地开发</h1><p><code>http://localhost</code> 您可能会遇到行为不像 HTTPS 站点的特殊情况，或者您可能只想使用不是 <code>http://localhost</code>。</p><p>以下情况需要使用HTTPS进行本地开发：</p><ul><li>You need to set a cookie locally that is <code>Secure</code>, or <code>SameSite:none</code>, or has the <code>__Host</code> prefix. <code>Secure</code> cookies are set only on HTTPS, but not on <code>http://localhost</code> for all browsers. And because <code>SameSite:none</code> and <code>__Host</code> also require the cookie to be <code>Secure</code>, setting such cookies on your local development site requires HTTPS as well.</li><li>You need to debug locally an issue that only occurs on an HTTPS website but not on an HTTP site, not even <a href="http://localhost" target="_blank" rel="external">http://localhost</a>, such as a mixed-content issue.</li><li>You need to locally test or reproduce a behaviour specific to HTTP/2 or newer. For example, if you need to test loading performance on HTTP/2 or newer. Insecure HTTP/2 or newer is not supported, not even on <code>localhost</code>.</li><li>You need to locally test third-party libraries or APIs that require HTTPS (for example OAuth).</li><li>You’re not using localhost, but a custom host name for local development, for example mysite.example. Typically, this means you’ve overridden your local hosts file:<br><img src="/images/when-https-2.jpg" alt><br><p style="text-align: center; font-size: 14px; color: #888; font-style: oblique;">Editing a hosts file to add a custom hostname.</p><br>In this case, Chrome, Edge, Safari, and Firefox by default do not consider <code>mysite.example</code> to be secure, even though it’s a local site. So it won’t behave like an HTTPS site.</li><li>Other cases! This is not an exhaustive list, but if you encounter a case that’s not listed here, you’ll know: things will break on <a href="http://localhost" target="_blank" rel="external">http://localhost</a>, or it won’t quite behave like your production site. 🙃</li></ul><p>在所有这些情况下，您都需要使用 HTTPS 进行本地开发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大多数情况下，使用 &lt;a href=&quot;http://localhost&quot;&gt;http://localhost&lt;/a&gt; 进行本地开发是可以的，但在某些特殊情况下除外。之前也介绍过了如何使用 HTTPS 进行本地开发。这篇文章解释了何时需要使用 HTTPS 运行本地开发站点。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="NodeJS" scheme="https://neveryu.github.io/tags/NodeJS/"/>
    
      <category term="HTTPS" scheme="https://neveryu.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 HTTPS 进行本地开发</title>
    <link href="https://neveryu.github.io/2023/how-to-use-local-https/"/>
    <id>https://neveryu.github.io/2023/how-to-use-local-https/</id>
    <published>2023-02-28T22:25:24.000Z</published>
    <updated>2023-04-04T11:36:48.291Z</updated>
    
    <content type="html"><![CDATA[<p>有时，您需要使用 HTTPS 运行本地开发网站。本文介绍了安全快速地执行此操作的工具和技巧。</p><a id="more"></a><p id="div-border-top-red"><i>在大多数情况下，<code>http://localhost</code> 就可以满足您的需求：在浏览器中，它的行为与 HTTPS 🔒 非常类似。因此，部分无法在部署的 HTTP 网站上运行的 API 可以在 <code>http://localhost</code> 上运行。 <strong>这意味着您只需要在特殊情况下才需要在本地使用 HTTPS</strong>（<a href>请参阅何时使用 HTTPS 进行本地开发</a>），例如自定义主机名或跨浏览器的安全 cookie。如果您有这种需求，请继续阅读！</i></p><p><i style="color: #df3e3e;">如果你使用了一种简单（非正规）的操作，开启的 HTTPS 环境，那么，很可能，你会遇到下面的情况</i><br><img src="/images/use-https-3.png" alt></p><blockquote><p>当然，你可以选择：高级 -&gt; 继续访问。<br>但浏览器依然会提示我们，这是一个不安全的访问。</p></blockquote><p><strong>本文介绍一些安全快速地使用 HTTPS 运行本地开发网站的工具和技巧；浏览器不再提示告警！</strong></p><p>在本文中，关于 <code>localhost</code> 的声明也适用于 <code>127.0.0.1</code> 和 <code>[::1]</code> ，因为它们都描述了本地计算机地址，也称为“环回地址”。此外，为简单起见，未指定端口号。因此，请将 <code>http://localhost</code> 解读为 <code>http://localhost:{PORT}</code> 或 <code>http://127.0.0.1:{PORT}</code>。</p><p>如果您在生产网站使用了 HTTPS，并希望本地开发网站的行为可以接近 HTTPS 网站（如果您的生产网站还没有使用 HTTPS，请优先切换到 HTTPS ）。在大多数情况下，您可以认为 <a href="http://localhost" target="_blank" rel="external">http://localhost</a> 的行为类似于 HTTPS 网站。但在某些情况下，您需要使用 HTTPS 在本地运行网站。现在来看看如何做到这一点。</p><h1 id="使用-mkcert-为本地网站开启-HTTPS（推荐）"><a href="#使用-mkcert-为本地网站开启-HTTPS（推荐）" class="headerlink" title="使用 mkcert 为本地网站开启 HTTPS（推荐）"></a>使用 mkcert 为本地网站开启 HTTPS（推荐）</h1><p>要为本地开发网站开启 HTTPS 并访问 <a href="https://localhost" target="_blank" rel="external">https://localhost</a> ，您需要 <a href="/2023/how-to-generate-and-use-an-SSL-certificate-in-Node/">TLS 证书</a>。<strong>但并非任何证书都会被浏览器接受：证书需要由您的浏览器信任的实体签名，这些实体称之为<a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="external">可信证书颁发机构(CA)</a></strong> 。</p><p>您需要创建一个证书，并使用受您的设备和浏览器<strong>本地信任的CA</strong>对其进行签名。您可以使用工具 <strong><a href="https://github.com/FiloSottile/mkcert" target="_blank" rel="external">mkcert</a></strong> 通过几个命令来实现这个目的。下面介绍了它的工作原理：</p><ul><li>如果您使用 HTTPS 在浏览器中打开本地运行的网站，浏览器将检查本地开发服务器的证书。</li><li>在看到证书已由 mkcert 生成的证书颁发机构签名后，浏览器会检查它是否已注册为受信任的证书颁发机构。</li><li>mkcert 已被列为受信任的颁发机构，所以浏览器会信任该证书并创建 HTTPS 连接。</li></ul><p><img src="/images/use-https-2.jpg" alt></p><p style="text-align: center; font-size: 14px; color: #888; font-style: oblique;"> mkcert 工作原理图</p><p>mkcert（和类似工具）具备下列几种优势：</p><ul><li><p>mkcert 专门用于创建<strong>与浏览器认为有效相兼容的证书</strong>。它会保持更新，来满足需求和最佳实践。因此您无需运行具备复杂配置或参数的 mkcert 命令，就可以生成正确的证书！</p></li><li><p>mkcert 是跨平台的工具。团队中的任何人都可以使用。<br>我们推荐使用 mkcert 为本地开发创建 TLS 证书。您也可以查看其他选择。</p></li></ul><p>许多操作系统可能会提供用于生成证书的库，例如 <a href="https://www.openssl.org/" target="_blank" rel="external">openssl</a>。与 mkcert 和类似工具不同，此类库可能无法始终生成正确的证书，或可能需要运行复杂的命令，并且不一定能够跨平台使用。</p><p id="div-border-top-red"><i>1、运行 <code>mkcert -install</code> 时，切勿导出或分享由 mkcert 自动创建的 <code>rootCA-key.pem</code> 。获得此文件的攻击者可以对您可能正在访问的任何网站进行路径攻击。他们可以拦截从您的电脑到任何网站（银行、医保供应商或社交网络）的安全请求。如果您需要知道 <code>rootCA-key.pem</code> 的位置以确保其安全，请运行 <code>mkcert -CAROOT</code>。<br>2、仅将 mkcert 用于<strong>开发目的</strong>，并且永远不要要求最终用户运行 mkcert 命令。<br>3、开发团队：所有团队成员都应该单独安装和运行 mkcert（而不是存储和共享 CA 和证书）。</i></p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>1、安装 mkcert（仅一次）。<br>按照<a href="https://github.com/FiloSottile/mkcert#installation" target="_blank" rel="external">操作说明</a>在操作系统上安装 mkcert。例如，在 macOS 上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install mkcert</span><br><span class="line">brew install nss <span class="comment"># if you use Firefox</span></span><br></pre></td></tr></table></figure><p>2、将 mkcert 添加到本地根 CA。<br>在终端运行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkcert -install</span><br></pre></td></tr></table></figure></p><p>这会生成本地证书颁发机构 (CA)。mkcert 生成的本地 CA 仅在您的设备上<strong>本地</strong>受信。</p><p>3、为网站生成一个由 mkcert 签名的证书。<br>在终端中，导航到网站的根目录或用来保存证书的任何目录。<br>然后运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkcert localhost</span><br></pre></td></tr></table></figure></p><p>如果您的自定义主机名是 <code>mysite.example</code>，请运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkcert mysite.example</span><br></pre></td></tr></table></figure><p>上面的命令执行了两个操作：</p><ul><li>为您指定的主机名生成证书</li><li>让 mkcert（您在步骤 2 中添加为本地 CA）签署此证书。</li></ul><p>现在证书已准备就绪，并且已由您的浏览器在本地信任的证书颁发机构签名。大部分步骤已经完成，但您的服务器现在还不了解这个证书！</p><p>4、配置服务器。<br>您现在需要告诉服务器使用 HTTPS（因为默认情况下开发服务器倾向使用 HTTP）并使用您刚刚创建的 TLS 证书。<br>具体的操作取决于您的服务器。下面列出了几个例子：</p><h3 id="👩🏻‍💻-使用节点："><a href="#👩🏻‍💻-使用节点：" class="headerlink" title="👩🏻‍💻 使用节点："></a>👩🏻‍💻 使用节点：</h3><p><code>server.js</code> （替换<code>{PATH/TO/CERTIFICATE...}</code>和<code>{PORT}</code> ）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const https = require(<span class="string">'https'</span>);</span><br><span class="line">const fs = require(<span class="string">'fs'</span>);</span><br><span class="line">const options = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">'&#123;PATH/TO/CERTIFICATE-KEY-FILENAME&#125;.pem'</span>),</span><br><span class="line">  cert: fs.readFileSync(<span class="string">'&#123;PATH/TO/CERTIFICATE-FILENAME&#125;.pem'</span>),</span><br><span class="line">&#125;;</span><br><span class="line">https</span><br><span class="line">  .createServer(options, <span class="keyword">function</span> (req, res) &#123;</span><br><span class="line">    // server code</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(&#123;PORT&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="👩🏻‍💻-使用-http-server：（【推荐前端同学用这个】）"><a href="#👩🏻‍💻-使用-http-server：（【推荐前端同学用这个】）" class="headerlink" title="👩🏻‍💻 使用 http-server：（【推荐前端同学用这个】）"></a>👩🏻‍💻 使用 http-server：（【推荐前端同学用这个】）</h3><p>按如下方式启动服务器（替换{PATH/TO/CERTIFICATE…} ）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server -S -C &#123;PATH/TO/CERTIFICATE-FILENAME&#125;.pem -K &#123;PATH/TO/CERTIFICATE-KEY-FILENAME&#125;.pem</span><br></pre></td></tr></table></figure></p><p><code>-S</code> 会用 HTTPS 运行服务器，<code>-C</code> 用来设置证书，<code>-K</code> 用来设置密钥。</p><h3 id="👩🏻‍💻-使用-React-开发服务器："><a href="#👩🏻‍💻-使用-React-开发服务器：" class="headerlink" title="👩🏻‍💻 使用 React 开发服务器："></a>👩🏻‍💻 使用 React 开发服务器：</h3><p>按下列方式编辑 <code>package.json</code> ，并替换<code>{PATH/TO/CERTIFICATE...}</code> ：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "HTTPS=true SSL_CRT_FILE=&#123;PATH/TO/CERTIFICATE-FILENAME&#125;.pem SSL_KEY_FILE=&#123;PATH/TO/CERTIFICATE-KEY-FILENAME&#125;.pem react-scripts start"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如，如果您按照下列操作在网站根目录中为 localhost 创建了证书：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-- my-react-app</span><br><span class="line">  |-- package.json</span><br><span class="line">  |-- localhost.pem</span><br><span class="line">  |-- localhost-key.pem</span><br><span class="line">  |--...</span><br></pre></td></tr></table></figure></p><p>那么 <code>start</code> 脚本应该是这样的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "HTTPS=true SSL_CRT_FILE=localhost.pem SSL_KEY_FILE=localhost-key.pem react-scripts start"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="👩🏻‍💻-其他例子："><a href="#👩🏻‍💻-其他例子：" class="headerlink" title="👩🏻‍💻 其他例子："></a>👩🏻‍💻 其他例子：</h3><ul><li><a href="https://angular.io/cli/serve" target="_blank" rel="external">Angular 开发服务器</a></li><li><a href="https://blog.anvileight.com/posts/simple-python-http-server/" target="_blank" rel="external">Python</a></li></ul><p>5、✨全部搞定！在浏览器中打开 <code>https://localhost</code> 或 <code>https://mysite.example</code> ：这时就在使用 HTTPS 在本地运行您的网站。<strong>您不会看到任何浏览器警告</strong>，因为浏览器已将 mkcert 认作是本地证书颁发机构。</p><p id="div-border-left-green"><i>服务器可以使用不同的 HTTPS 端口。</i></p><p id="div-border-left-green"><i>请仅用于开发目的，切勿导出或分享 <code>rootCA-key.pem</code> 文件（如果您需要知道此文件的位置以确保其安全，请运行 <code>mkcert -CAROOT</code> ）。</i></p><blockquote><p>关于生成证书这一步，openssl 也可以做到，mkcert 也可以做到；但光有证书还不够。<br>mkcert 更关键的一步是：可以生成本地证书颁发机构 (CA)。mkcert 生成的本地 CA 仅在您的设备上本地受信。</p></blockquote><h1 id="在本地网站开启-HTTPS：其他方法"><a href="#在本地网站开启-HTTPS：其他方法" class="headerlink" title="在本地网站开启 HTTPS：其他方法"></a>在本地网站开启 HTTPS：其他方法</h1><h2 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h2><p>您也可以不使用 mkcert 这样的本地证书颁发机构，而是<strong>自己签署证书</strong>。</p><p>请注意这种方法的一些缺点：</p><ul><li>浏览器不信任您的证书颁发机构身份，因此会显示警告，您需要手动绕过。在 Chrome 中，您可以使用标志 <code>#allow-insecure-localhost</code> <code>localhost</code> 自动绕过此警告。这确实有些麻烦。</li><li>如果您的网络环境不安全，此举会带来潜在风险。</li><li>自签名证书的行为方式与受信任证书的行为方式不同。</li><li>它不一定比使用 mkcert 这样的本地 CA 更方便或更快捷。</li><li>如果您没有在浏览器上下文中使用此技术，则可能需要禁用服务器的证书验证。在生产中忘记重新启用它会带来潜在风险。</li></ul><p><img src="/images/use-https-4.jpg" alt></p><p style="text-align: center; font-size: 14px; color: #888; font-style: oblique;"> 使用自签名证书时浏览器显示的警告。 </p><p id="div-border-top-blue"><i>如果您没有指定任何证书，那么 React 和 Vue 的开发服务器 HTTPS 选项会在后台创建一个自签名证书。这样虽然很快捷，但您会收到浏览器警告，并遇到与上面列出的与自签名证书相关的其他问题。幸运的是，您可以使用前端框架的内置 HTTPS 选项并指定由 mkcert 或类似工具创建的本地可信证书。请前往React 与 mkcert 示例查看如何执行此操作。</i></p><h2 id="为什么浏览器不信任自签名证书？"><a href="#为什么浏览器不信任自签名证书？" class="headerlink" title="为什么浏览器不信任自签名证书？"></a>为什么浏览器不信任自签名证书？</h2><p>如果您使用 HTTPS 在浏览器中打开本地运行的网站，浏览器将检查本地开发服务器的证书。当它看到证书由您签名时，它会检查您是否已注册为受信任的证书颁发机构。因为您不是，所以浏览器不能信任此证书；它会警告您的连接不安全。您可以自行承担风险。如果选择这样，那么将创建 HTTPS 连接。</p><p><img src="/images/use-https-5.jpg" alt></p><p style="text-align: center; font-size: 14px; color: #888; font-style: oblique;">为什么浏览器不信任自签名证书。</p><h1 id="由常规证书颁发机构签署的证书"><a href="#由常规证书颁发机构签署的证书" class="headerlink" title="由常规证书颁发机构签署的证书"></a>由常规证书颁发机构签署的证书</h1><p>您还可以找到基于由实际证书颁发机构（而不是本地机构）签署证书的技术。<br>如果您在考虑使用这些技术，请记住以下几点：</p><ul><li>与 mkcert 这样的本地 CA 技术相比，您需要投入更多的设置工作。</li><li>您需要使用由自己控制且有效的域名。这表示实际的证书颁发机构无法用于：<ul><li><code>localhost</code> 和其他<a href="https://www.iana.org/assignments/special-use-domain-names/special-use-domain-names.xhtml" target="_blank" rel="external">保留</a>域名，例如 <code>example</code> 或 <code>test</code> 。</li><li>您无法控制的任何域名。</li><li>无效的顶级域。请参阅<a href="https://www.iana.org/domains/root/db" target="_blank" rel="external">有效顶级域</a>的列表。</li></ul></li></ul><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>使用 HTTPS 访问本地运行网站的另一种方法是使用<a href="https://en.wikipedia.org/wiki/Reverse_proxy" target="_blank" rel="external">反向代理</a>，例如 <a href="https://ngrok.com/" target="_blank" rel="external">ngrok</a> 。</p><p>需要考虑的几点：</p><ul><li>一旦您与任何用户分享了使用反向代理创建的 URL，他们都可以访问您的本地开发网站。这在向客户演示您的项目时非常方便！但如果您的项目很敏感，这可能是一个缺点。</li><li>您可能需要考虑定价。</li><li>浏览器新引入的安全措施可能会影响这些工具的表现。</li></ul><h1 id="标志法（不推荐）"><a href="#标志法（不推荐）" class="headerlink" title="标志法（不推荐）"></a>标志法（不推荐）</h1><p>如果您使用了 <code>mysite.example</code> 这样的自定义主机名，那么可以在 Chrome 中使用标志来强制将 <code>mysite.example</code> 认作是安全的。<strong>请避免使用这种方法</strong>，因为：</p><ul><li>您需要 100% 确定 <code>mysite.example</code> 始终解析为本地地址，否则可能会泄露生产凭据。</li><li>此方法不支持跨浏览器调试 🙀</li></ul><p><a href="https://web.dev/i18n/zh/how-to-use-local-https/#running-your-site-locally-with-https-other-options" target="_blank" rel="external">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时，您需要使用 HTTPS 运行本地开发网站。本文介绍了安全快速地执行此操作的工具和技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="NodeJS" scheme="https://neveryu.github.io/tags/NodeJS/"/>
    
      <category term="HTTPS" scheme="https://neveryu.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>如何在 NodeJS 中生成和使用 SSL 证书</title>
    <link href="https://neveryu.github.io/2023/how-to-generate-and-use-an-SSL-certificate-in-Node/"/>
    <id>https://neveryu.github.io/2023/how-to-generate-and-use-an-SSL-certificate-in-Node/</id>
    <published>2022-12-31T22:25:24.000Z</published>
    <updated>2023-03-30T14:12:21.986Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中，我们将了解如何为我们的开发服务器生成 SSL 证书。稍后，我们将看到如何在我们的应用程序中使用该证书。</p><a id="more"></a><p>先进入到项目中去，假设项目名为：<code>node-ssl-server</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> node-ssl-server</span><br></pre></td></tr></table></figure></p><h1 id="让我们生成-SSL-证书"><a href="#让我们生成-SSL-证书" class="headerlink" title="让我们生成 SSL 证书"></a>让我们生成 SSL 证书</h1><p>要生成 SSL 证书，我们需要按照以下步骤操作：</p><ul><li>生成私钥</li><li>使用私钥创建 CSR（证书签名请求）</li><li>从 CSR 生成 SSL 证书</li></ul><h2 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h2><p>要生成私钥，我们将运行此命令，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out key.pem</span><br></pre></td></tr></table></figure></p><p>运行上述命令后，它将生成私钥并将其保存在生成的 <code>key.pem</code> 文件中，并在终端中提供此类消息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Generating RSA private key, 2048 bit long modulus</span><br><span class="line">...+++</span><br><span class="line">.................+++</span><br><span class="line">e is 65537 (0x10001)</span><br></pre></td></tr></table></figure></p><h2 id="创建-CSR（证书签名请求）"><a href="#创建-CSR（证书签名请求）" class="headerlink" title="创建 CSR（证书签名请求）"></a>创建 CSR（证书签名请求）</h2><p>由于我们是自己的证书颁发机构，因此我们需要使用 <code>CSR</code> 来生成我们的证书。为此，我们需要运行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key key.pem -out csr.pem</span><br></pre></td></tr></table></figure></p><p>运行此命令后，它会询问几个问题，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields, there will be a default value,</span><br><span class="line">If you enter <span class="string">'.'</span>, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [XX]:CH</span><br><span class="line">State or Province Name (full name) []:</span><br><span class="line">Locality Name (eg, city) [Default City]:</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:</span><br><span class="line">Organizational Unit Name (eg, section) []:</span><br><span class="line">Common Name (eg, your name or your server<span class="string">'s hostname) []:</span></span><br><span class="line"><span class="string">Email Address []:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Please enter the following '</span>extra<span class="string">' attributes</span></span><br><span class="line"><span class="string">to be sent with your certificate request</span></span><br><span class="line"><span class="string">A challenge password []:</span></span><br><span class="line"><span class="string">An optional company name []:</span></span><br></pre></td></tr></table></figure></p><p>除了 <code>Country Name</code> 是必须填写的之外（我填写的是 <code>CN</code>），如果您不想提供其他的详细信息，只需按回车键即可跳过任何问题，这完全取决于您。</p><p>完成这些问题后，它将在文件夹内的 <code>csr.pem</code> 文件中生成 <code>CSR</code> 。</p><h2 id="生成-SSL-证书"><a href="#生成-SSL-证书" class="headerlink" title="生成 SSL 证书"></a>生成 SSL 证书</h2><p>现在进行最后的步骤，我们需要使用 <code>key.pem</code> 和 <code>crs.pem</code> 文件来生成我们的 SSL 证书。</p><p>让我们运行下面的命令来生成它：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> csr.pem -signkey key.pem -out cert.pem</span><br></pre></td></tr></table></figure></p><h3 id="笔记："><a href="#笔记：" class="headerlink" title="笔记："></a>笔记：</h3><ul><li>我们使用x509，因为它是定义公钥证书格式的标准。</li><li>我们将证书的有效期设置为 365 天。</li></ul><p>运行上述命令后，它将证书保存在项目文件夹内的 <code>cert.pem</code> 文件中。现在您可以删除 <code>csr.pem</code> 文件，也可以保留它。</p><h1 id="在-NodeJS-中集成-SSL-证书"><a href="#在-NodeJS-中集成-SSL-证书" class="headerlink" title="在 NodeJS 中集成 SSL 证书"></a>在 NodeJS 中集成 SSL 证书</h1><p>现在让我们使用文件系统 (fs) 和路径模块在我们的应用程序中使用这些证书。为此，我们需要在我们的应用程序中编辑测试，如下所述：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>) <span class="comment">// https module to create a ssl enabled server</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>) <span class="comment">// path module </span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>) <span class="comment">//file system module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options =&#123;</span><br><span class="line">  key:fs.readFileSync(path.join(__dirname,<span class="string">'./certs/key.pem'</span>)),</span><br><span class="line">  cert:fs.readFileSync(path.join(__dirname,<span class="string">'./certs/cert.pem'</span>)) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sslserver = https.createServer(options, (req, res) =&gt; &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>)</span><br><span class="line">  res.end(<span class="string">'hello https\n'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sslserver.listen(<span class="number">8088</span>, () =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">'Secure Server is listening on port 8088'</span>) &#125;)</span><br></pre></td></tr></table></figure></p><p>您可以通过从这个 URL 访问它来检查 HTTPS 是否正常工作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://localhost:8088</span><br></pre></td></tr></table></figure></p><p>或者，</p><p>你也可以在终端使用命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -k https://localhost:8088/</span><br></pre></td></tr></table></figure></p><blockquote><p><code>-k</code> 参数指定跳过 SSL 检测；上面命令不会检查服务器的 SSL 证书是否正确，仅测试连通性。</p></blockquote><h1 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h1><p>虽然我们有一个有效的证书，但您可能会在浏览器中看到不安全，这只是因为我们已经生成了证书，而它不是由某些已知的证书颁发机构生成的，因此，您的浏览器不信任您作为有效的证书颁发机构。但是我们通常应该将此过程用于开发目的，而对于生产，我们应该使用由证书颁发机构（如Let’s Encrypt）生成的证书。</p><p><a href="https://deviloper.in/ssl-certificate-in-nodejs" target="_blank" rel="external">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本文中，我们将了解如何为我们的开发服务器生成 SSL 证书。稍后，我们将看到如何在我们的应用程序中使用该证书。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="NodeJS" scheme="https://neveryu.github.io/tags/NodeJS/"/>
    
      <category term="SSL" scheme="https://neveryu.github.io/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 为何重要</title>
    <link href="https://neveryu.github.io/2022/why-https-matters/"/>
    <id>https://neveryu.github.io/2022/why-https-matters/</id>
    <published>2022-10-01T00:20:00.000Z</published>
    <updated>2023-04-04T11:36:39.988Z</updated>
    
    <content type="html"><![CDATA[<p>您应该始终使用 HTTPS 保护您的所有网站，即使这些网站不处理敏感通信也应如此。除了为您的网站和用户的个人信息提供关键的安全性和数据完整性之外，HTTPS 还是使用许多新浏览器功能的必要前提，尤其是渐进式 Web 应用程序所需的功能。</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><ul><li>恶意和良性入侵者都会利用您的网站和用户间的每一个未受保护的资源。</li><li>许多入侵者通过查看群体行为来识别您的用户。</li><li>HTTPS 不仅可以阻止滥用您的网站，也是使用许多最新功能的前提，还能为 Service Worker 等类似应用程序功能提供支持。</li></ul><a id="more"></a><h1 id="HTTPS-为您的网站保驾护航"><a href="#HTTPS-为您的网站保驾护航" class="headerlink" title="HTTPS 为您的网站保驾护航"></a>HTTPS 为您的网站保驾护航</h1><p>HTTPS 可帮助您阻止入侵者篡改您的网站与用户浏览器间的通信。入侵者包括故意的恶意攻击者，以及合法但具有侵入性的公司，例如 ISP 或在网页中植入广告的酒店。</p><p>入侵者利用未受保护的通信来诱使您的用户放弃敏感信息或安装恶意软件，或者将他们的广告插入您的资源中。例如，一些第三方会在网站中植入广告，这可能会破坏用户体验并造成安全漏洞。</p><p>入侵者会利用在您的网站和用户之间传输的所有未受保护的资源。图像、cookie、脚本、HTML……它们都可以被利用。入侵可能发生在网络中的任何一环，包括用户的电脑、Wi-Fi 热点或有安全漏洞的 ISP，这些只是其中的一小部分。</p><h1 id="HTTPS-保护您用户的隐私和安全"><a href="#HTTPS-保护您用户的隐私和安全" class="headerlink" title="HTTPS 保护您用户的隐私和安全"></a>HTTPS 保护您用户的隐私和安全</h1><p>HTTPS 可防止入侵者被动监听您的网站与用户之间的通信。</p><p>关于 HTTPS 的一个常见误解是，只有处理敏感通信的网站才需要 HTTPS。事实上每个未受保护的 HTTP 请求都可能泄露有关用户行为和身份的信息。尽管对您未受保护的网站的单次访问看似没有恶意，但一些入侵者会查看您用户的总体浏览活动，从而推断他们的行为和意图，并对他们的身份进行<a href="https://en.wikipedia.org/wiki/Data_re-identification" target="_blank" rel="external">去匿名化</a>。例如，员工可能只是阅读未受保护的医疗文章而无意中向雇主透露了敏感的健康状况。</p><h1 id="HTTPS-是网络的未来"><a href="#HTTPS-是网络的未来" class="headerlink" title="HTTPS 是网络的未来"></a>HTTPS 是网络的未来</h1><p>一些新的 Web 平台功能十分强大，例如使用 <code>getUserMedia()</code> 拍照或录制音频，通过 <code>Service Worker</code> 实现离线应用程序体验，或构建渐进式 Web 应用程序。这些功能在执行之前都需要用户的明确许可。许多早期的 API 也正在更新以要求获得执行权限，例如 <a href="https://developer.mozilla.org/docs/Web/API/Geolocation/Using_geolocation" target="_blank" rel="external">Geolocation API</a>。HTTPS 正是这些新功能和更新 API 的权限工作流的关键组成部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;您应该始终使用 HTTPS 保护您的所有网站，即使这些网站不处理敏感通信也应如此。除了为您的网站和用户的个人信息提供关键的安全性和数据完整性之外，HTTPS 还是使用许多新浏览器功能的必要前提，尤其是渐进式 Web 应用程序所需的功能。&lt;/p&gt;
&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;恶意和良性入侵者都会利用您的网站和用户间的每一个未受保护的资源。&lt;/li&gt;
&lt;li&gt;许多入侵者通过查看群体行为来识别您的用户。&lt;/li&gt;
&lt;li&gt;HTTPS 不仅可以阻止滥用您的网站，也是使用许多最新功能的前提，还能为 Service Worker 等类似应用程序功能提供支持。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTTPS" scheme="https://neveryu.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>在公共部门做通用服务的一些感悟</title>
    <link href="https://neveryu.github.io/2022/thoughts-1/"/>
    <id>https://neveryu.github.io/2022/thoughts-1/</id>
    <published>2022-05-31T22:00:00.000Z</published>
    <updated>2022-06-07T23:38:43.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>入职滴滴一年，造了不少公司级别的“轮子”，不少轮子已经在业务线跑起来了，运行状况还算可以。我自己也总结了做通用服务要注意的几点：</p><h2 id="1-一定要好用，用起来要简单。"><a href="#1-一定要好用，用起来要简单。" class="headerlink" title="1.一定要好用，用起来要简单。"></a>1.一定要好用，用起来要简单。</h2><p>这是我一直贯彻的理念，如果你写的通用服务不好用，那一定会受到质疑和吐槽。同样我们用开源的框架，也一定会选简单好用的，当年 jQuery，prototype，tangram 等 JS 库百家争鸣的时候，jQuery笑到了最后，为什么呢，很简单的一点 jQuery好用啊，一个 <code>$(xxx)</code> 搞定一切。相比 <code>tangram</code> 那种 <code>Baidu.T.createDom()</code> 的方式，高下立判。</p><p>我们在设计通用 JS 库的时候，一定要站在更高的角度去对需求做抽象。比如我在设计统一登录 SDK，首先要想的不是复杂的交互逻辑、如何去实现、有哪些技术难点，而是去想，别人怎么用这个库，怎么用起来爽。登录的需求就是用户触发一个登录动作，登录完成能拿到用户一些信息，所以我就设计一个 <code>login(callback)</code>接口，那么使用方只需要简单调用这个方法，就可以完成登录需求，而不用去关心登录各种复杂的细节。</p><a id="more"></a><h2 id="2-该做封装的地方要封装，对外暴露的接口越少越好。"><a href="#2-该做封装的地方要封装，对外暴露的接口越少越好。" class="headerlink" title="2.该做封装的地方要封装，对外暴露的接口越少越好。"></a>2.该做封装的地方要封装，对外暴露的接口越少越好。</h2><p>封装很重要，举个通俗的例子，有一天我去洗手，发现水龙头的开关把手没了，把原始的开关暴露给我了，也能用，但是体验就会很不好。水龙头的开关把手就是对原始开关的封装。我在做 JSBridge 库 的时候，也是一样的道理，如果让用户直接调用 IOS 和 Andrid 提供的原生 bridge 接口的，也能 work，但是非常难用，需要判断 IOS 和 Android 接口的差异，还需要考虑 bridge ready 事件后才能执行方法等，这些都是我原本不需要关心的细节。所以我们的库就是帮助用户封装掉这些“脏活”，对外提供简单的 <code>DDBridge.funcName(options,callback)</code> 接口，优化使用体验。</p><p>为什么说对外暴露的接口越少越好，因为接口越多，则说明用户的学习成本越高，比如如火如荼的 Vue.js，1.x 版本很多接口的功能大同小异，所以在 2.0 版本的 Vue 就干掉了很多接口，减少了用户的学习成本。同样的，我们在做 JSBridge 分享接口相关的时候，也通过一个 share 接口封装了端提供的微信分享、支付宝分享、微博分享等接口。</p><h2 id="3-先思考再动手，设计合理的代码组织方式。"><a href="#3-先思考再动手，设计合理的代码组织方式。" class="headerlink" title="3.先思考再动手，设计合理的代码组织方式。"></a>3.先思考再动手，设计合理的代码组织方式。</h2><p>我们在写代码之前，一定要先思考清楚，切忌上来就写代码，那样很容易写成一波流代码。合理的代码组织方式，有利于代码的扩展和维护，最基本的就是模块化。这里没有银弹，需要大量的实践和总结，学会抽象的看问题，看一些设计模式相关多书籍，多看优秀的开源的代码，可以先从模仿开始。</p><p>由于我们写的是通用服务，用户也可能会提出各种需求，当我们遇到这个问题的时候，不能上来就写代码去实现甚至 hack，而是先思考这个需求是不是可以抽象成通用的需求，如果不能抽象，我们如何更优雅的实现，之前的设计是不是有问题。总之，要多想多思考，也可以和小伙伴讨论，争取做到是在设计代码而不是堆代码。</p><h2 id="4-追求体验极致。"><a href="#4-追求体验极致。" class="headerlink" title="4.追求体验极致。"></a>4.追求体验极致。</h2><p>现在很多前端都在玩 <code>node</code>，玩构建工具，玩 mvvm 框架，玩 es6，好像感觉学会了这些就可以提高身价。其实，这些大部分都是工具、服务我们平时工作的，不要忘了我们的本行还是前端，还是需要写页面的。其实前端有些组件和效果如果想要追求体验极致的话，也不容易。如果能做到极致，身价也不会低。举个例子，我在写 mofang 移动端组件的时候，有个筛选器组件 picker，类似 IOS 原生 UIPickerView 的东东，我当时拿到需求的时候，也从 github 上搜索过，没有满意的，体验都很一般，于是我就对比 IOS 原生的 UIPickerView 的体验，思考它的实现、一点点细节的调试，最终也撸出来体验几乎一致的移动端 h5 picker 组件。举这个例子其实想说明，我们在做通用服务的时候，要多花心思，如果能做出一些极致体验的东东，不仅对用户来说他们很乐意使用，对自己也是一种锻炼。</p><h2 id="5-一定要写-wiki"><a href="#5-一定要写-wiki" class="headerlink" title="5.一定要写 wiki"></a>5.一定要写 wiki</h2><p>要写 wiki！要写 wiki!要写 wiki！重要的事情说 3 遍。由于我们做通用服务，免不了和用户打交道，wiki 就尤为重要了。我们需要把通用服务的接口，使用方式，常见问题等都写清楚，。好的文档可以很好的指导用户如何使用我们的服务，这样可以大大的减少沟通成本，节约我们自身和用户的时间。</p><h2 id="6-要学会销售。"><a href="#6-要学会销售。" class="headerlink" title="6.要学会销售。"></a>6.要学会销售。</h2><p>有些人可能会觉得写通用服务似乎比做业务的同学更高大上，其实不然，本质上我们都是在为公司打工，都是在输出自己的价值，只是做事的重心不同。那么做公共的同学的价值在哪里，就是让自己写的通用服务被更多的人用，去提升他们的工作效率。所以，我们要学会销售自己的服务，而不是写完一个的服务摆出一副你爱用不用的态度。如果你写出来的东西没人用，就算它再牛逼，对公司的价值也是 0。另外，我们还要学会从业务中去沉淀服务，要去发现业务中的痛点，可以提升效率的地方，然后用技术的手段和工具去解决它。</p><h2 id="7-一颗服务的心。"><a href="#7-一颗服务的心。" class="headerlink" title="7.一颗服务的心。"></a>7.一颗服务的心。</h2><p>做公共的同学一定要有颗服务的心。我们售卖的是自己的服务，那么也一定要做好售后服务，除了 wiki，各种沟通钉钉微信沟通群也要积极响应，耐心的去帮助用户解决问题，其实很多时候，都是靠着用户去帮我们去发现 bug ，完善功能和优化体验的。</p><h1 id="谈下我的个人成长"><a href="#谈下我的个人成长" class="headerlink" title="谈下我的个人成长"></a>谈下我的个人成长</h1><p>我入前端这行已经4年了，在学校的时候我是玩 <code>.net</code> 的，喜欢折腾。毕业后当然和大部分应届生一样，渴望进 BAT 这样的大公司，不过 BAT 几乎不招 <code>.net</code> 的岗位。由于我读研的时候做过一些网站方向的开发，所以就投了百度的一个相近的职位，web前端开发。这里我要特别感谢我百度的mentor张袁炜，他是一个对技术要求很高的人，受他的影响，我也成为一个对技术有追求的人。四年的工作经历，我写过页面，写过网页游戏、写过 chrome 插件、写过框架、写过组件、写过服务，由于一直在做不同的东西，每一年我都有所收获。</p><p>兴趣导向，有的时候我感觉写代码和玩游戏是一样爽的事情，我也很喜欢看优秀的开源作品，看看他们的代码设计、技术细节，会吸收一些不错的东西到自己平时的工作中。</p><p>前端这几年发展很快，新技术层出不穷，有的时候，我们要跳出自己的舒适圈，接纳一些新事物，新技术，去让自己不断学习，而不是满足于自己已掌握的那些技术。这里我不是去倡导滥用新技术，而是要保持一颗学习的心态，一颗包容的心态。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;入职滴滴一年，造了不少公司级别的“轮子”，不少轮子已经在业务线跑起来了，运行状况还算可以。我自己也总结了做通用服务要注意的几点：&lt;/p&gt;
&lt;h2 id=&quot;1-一定要好用，用起来要简单。&quot;&gt;&lt;a href=&quot;#1-一定要好用，用起来要简单。&quot; class=&quot;headerlink&quot; title=&quot;1.一定要好用，用起来要简单。&quot;&gt;&lt;/a&gt;1.一定要好用，用起来要简单。&lt;/h2&gt;&lt;p&gt;这是我一直贯彻的理念，如果你写的通用服务不好用，那一定会受到质疑和吐槽。同样我们用开源的框架，也一定会选简单好用的，当年 jQuery，prototype，tangram 等 JS 库百家争鸣的时候，jQuery笑到了最后，为什么呢，很简单的一点 jQuery好用啊，一个 &lt;code&gt;$(xxx)&lt;/code&gt; 搞定一切。相比 &lt;code&gt;tangram&lt;/code&gt; 那种 &lt;code&gt;Baidu.T.createDom()&lt;/code&gt; 的方式，高下立判。&lt;/p&gt;
&lt;p&gt;我们在设计通用 JS 库的时候，一定要站在更高的角度去对需求做抽象。比如我在设计统一登录 SDK，首先要想的不是复杂的交互逻辑、如何去实现、有哪些技术难点，而是去想，别人怎么用这个库，怎么用起来爽。登录的需求就是用户触发一个登录动作，登录完成能拿到用户一些信息，所以我就设计一个 &lt;code&gt;login(callback)&lt;/code&gt;接口，那么使用方只需要简单调用这个方法，就可以完成登录需求，而不用去关心登录各种复杂的细节。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="感想" scheme="https://neveryu.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>【转】关于如何写作的知乎问答</title>
    <link href="https://neveryu.github.io/2022/questions-in-writing/"/>
    <id>https://neveryu.github.io/2022/questions-in-writing/</id>
    <published>2022-05-19T22:00:00.000Z</published>
    <updated>2022-05-26T12:56:38.192Z</updated>
    
    <content type="html"><![CDATA[<p>如何写出 <strong>信手拈来</strong>、<strong>惊鸿一瞥</strong>、<strong>深入其境</strong>、<strong>欲罢不能</strong> 等等等等的文章？</p><ul><li><a href="http://www.zhihu.com/question/27969484" target="_blank" rel="external">对于新手来讲，写小说要做好哪些准备？</a></li><li><a href="http://www.zhihu.com/question/21845666" target="_blank" rel="external">新手写小说常会陷入哪些误区？</a></li><li><a href="http://www.zhihu.com/question/20815158" target="_blank" rel="external">什么叫做文字的张力？</a></li><li><a href="http://www.zhihu.com/question/22411485" target="_blank" rel="external">如何把人物写得立体？</a></li><li><a href="http://www.zhihu.com/question/28102971" target="_blank" rel="external">如何用 150 字写出一个让人欲罢不能的开头？</a></li></ul><a id="more"></a><ul><li><a href="http://www.zhihu.com/question/22460344" target="_blank" rel="external">作家都是如何提高构思能力的？</a></li><li><a href="http://www.zhihu.com/question/23820465" target="_blank" rel="external">如何写好一部小说的情色部分？</a></li><li><a href="http://www.zhihu.com/question/26395133" target="_blank" rel="external">怎样才算文笔好？</a></li><li><a href="http://www.zhihu.com/question/19591218" target="_blank" rel="external">怎样提升一个人的文笔？</a></li><li><a href="http://www.zhihu.com/question/22576459" target="_blank" rel="external">写作过程中如何控制节奏？</a></li><li><a href="http://www.zhihu.com/question/21306861" target="_blank" rel="external">如何创作一个多线叙事结构？</a></li></ul><p>扩展视野，乔老爷的脑洞：</p><ul><li><a href="http://www.zhihu.com/question/25148516" target="_blank" rel="external">为什么明知道故事是编的，人们还是那么在乎结局？</a></li><li><a href="http://www.zhihu.com/question/28548133" target="_blank" rel="external">怎样将《喜羊羊与灰太狼》写出《冰与火之歌》的感觉？</a></li><li><a href="http://www.zhihu.com/question/21771525" target="_blank" rel="external">有哪些美哭你的句子？</a></li><li><a href="http://www.zhihu.com/question/20121040" target="_blank" rel="external">你看过文笔最美的书是什么？</a></li><li><a href="http://www.zhihu.com/question/27073171" target="_blank" rel="external">如何把平常的事物写出恐怖的感觉？</a></li></ul><p>集大家之成，悟小家之道。取法乎上，得乎其中。</p><hr><p><strong> 文章系转载，<a href="https://notes.iissnan.com/2015/questions-in-writing/" target="_blank" rel="external">原文链接</a> </strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何写出 &lt;strong&gt;信手拈来&lt;/strong&gt;、&lt;strong&gt;惊鸿一瞥&lt;/strong&gt;、&lt;strong&gt;深入其境&lt;/strong&gt;、&lt;strong&gt;欲罢不能&lt;/strong&gt; 等等等等的文章？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/27969484&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;对于新手来讲，写小说要做好哪些准备？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/21845666&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;新手写小说常会陷入哪些误区？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/20815158&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;什么叫做文字的张力？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/22411485&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;如何把人物写得立体？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/28102971&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;如何用 150 字写出一个让人欲罢不能的开头？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="essay" scheme="https://neveryu.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>【转】聊聊 NexT 主题</title>
    <link href="https://neveryu.github.io/2022/something-about-next/"/>
    <id>https://neveryu.github.io/2022/something-about-next/</id>
    <published>2022-03-07T22:00:00.000Z</published>
    <updated>2022-05-24T23:21:26.277Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT 主题</a>快满一周岁了，值此之际，碎碎念一下（没有干货）。正如我在<a href="http://v2ex.com/t/165661" target="_blank" rel="external">V2EX 分享</a>时的介绍一样，NexT 的前身叫做 <a href="https://github.com/iissnan/hexo-theme-notes" target="_blank" rel="external">Notes</a>。在做 Notes 主题的时候，基于当时的需求出发点，从好听上来讲是简洁，不好听就是简陋（真直接，脸红）。</p><p><img src="https://raw.githubusercontent.com/iissnan/notes/gh-pages/uploads/something-about-next/theme-next.jpg" alt></p><a id="more"></a><p>Notes 开发于我刚接触 <a href="http://hexo.io" target="_blank" rel="external">Hexo</a> 时。当时我拥有一个基于 <a href="https://wordpress.org/" target="_blank" rel="external">WordPress</a> 的独立博客，这个博客主要用来写比较完整的技术类文章。在拖延症与技术挫的主观加客观因素综合作用下，这个独立博客也是产出寥寥。然而在丑小鸭能变美丽天鹅的唯美段子的安利下，我也是每天勤勤恳恳钻研技术（折腾不休）。每日阅读各路教程，搜索各种解决方案，追根溯源探索背后的原理，企图从根本上回答 “我是谁？我从哪里来？我要到哪里去？” 这类哲学问题。</p><p>在探索人生真谛的路上，为了防范捡了芝麻丢了西瓜这种愚蠢的问题，我果断想出一个方法，就是找个东西记下来。为了体现出折腾的本性，云记事本那根本不入法眼（要用也得自己开发，哎哟，很屌哦），然后又毙了 WordPress 独立博客，纯粹因为静态博客很火。那么，说好的以记录为主的目的丢到哪去了呢？</p><p>总之，结果是我折腾了 <a href="https://jekyllrb.com/" target="_blank" rel="external">Jekyll</a>、<a href="http://octopress.org/" target="_blank" rel="external">OctoPress</a>，最后落在 Hexo。作为选择困难户在选择静态生成博客的时候能够如此果断，那必然是因为只能选择会用的… 无论如何，使用 Hexo 还是挺顺手的，这里不得不夸下 Hexo 的整个代码设计很赞。但问题是我用了一圈就没一个对的上眼的主题。我要的其实很简单啊（遇到说这种话的客户，请直接拒绝，不要问我为什么），只要显示文章内容就好了啦，不要侧边栏啦，不要社交啦，最好字体好看点，排版优美点，颜色搭配舒服点，整体大气点，访问速度快一点，动画特效多一点。于是就有了 Notes（果然记录什么的这种事情不重要）。</p><p><img src="https://raw.githubusercontent.com/iissnan/notes/gh-pages/uploads/something-about-next/theme-notes-preview.png" alt></p><p>嗯，基本上就长这样，明显我自己还是比较好忽悠的，这没有一个点能匹配的上啊！（竟然只有两个 Release，不思上进也得有个度啊）。那么，Notes 使用了 <a href="http://jade-lang.com/" target="_blank" rel="external">Jade</a> 作为模板语言，其实还是大量参考了 Hexo 自带主题的模板结构，只是从 EJS 做了一次迁移。模仿是学习一件东西的最好开始（我最喜欢这种美丽的借口）。样式预编译语言是 <a href="https://learnboost.github.io/stylus/" target="_blank" rel="external">Stylus</a>，小众，我喜欢，尽管坑不少。Notes 里有几个功能在 NexT 中延续了下来。比如说 程序员 最爱的换代码主题，博主最爱的换主题皮肤（可以考虑学 LOL 做皮肤收费）等等一系列功能（其实也只有这两个）。总的来说，作为先锋，Notes 立下了汗马功劳。</p><p>一个突然的深夜，在一顿好生虐待键盘后。我来到了阳台烧起一根香，思考着如果把租用虚拟主机的钱用来抽更好点的烟这个疯狂的 idea。为了证明抽烟也可以省钱这个不切实际的想法，我果断停掉了 WordPress 独立博客。然而，在迁移在 WordPress  上原先那些无聊的文章，烦的把租用主机的费用都抽掉了。而 NexT 便是诞生于此之间。</p><p>NexT 在 Notes 的基础上做了大量的改动。首先是使用 Swig 将原先的 Jade 模板完全替换掉，对于记忆力不行还很懒的我来说，使用 Swig 还是比较接近 HTML ，好记易用不费力。 然后无聊企图用 <a href="http://sass-lang.com/" target="_blank" rel="external">Sass</a> 替换 Stylus 没有成功，所以还是 Stylus 继续耀武扬威。之后，在每一个版本中都加入一些常用的功能，让她更普遍化。</p><p>在制作 NexT 的过程中，第一要素是保证其易用性。如果一个功能超级炫丽，但难于使用，那宁可不做（真是漂亮的借口）。这一点可以追溯到偶像诗人白居易，他的诗可以通俗到妇孺皆知，确实有一定手段。那么 NexT 目标亦即如此，谨慎对待自己使用都觉得麻烦的功能。比如说，自定义 Icon Font 这个功能，其实我自己都觉得修改很麻烦，所以一直想把这个功能去除掉（在最近的一个版本中，我终于克服拖延症把它给去掉了）。</p><p>偶然一次看到了 苹果广告 视频里那个动画效果，羡慕嫉妒爱，于是就谋划着给 NexT 加上动画特效。本着本土流氓也要有国际黑帮气质的精神，我制作（抄袭）了许多个动画效果，后面都回滚掉了，着实可惜，此处没法装逼，自有装逼处。无论如何，结果是 NexT 加上了一些让浏览器抱怨不堪的动画效果，这完全是 <a href="http://julian.com/research/velocity/" target="_blank" rel="external">VelocityJS</a> 这个动画库的错。</p><p>日子就在花式拖延以及不负责任的抓 七星瓢虫 中悄悄流逝。又是一个凉如水的深夜，我把原先 Notes 中替换皮肤 （Scheme）的功能搬过来，并将其流水线化，利于多套 Scheme 的开发。说到 Scheme，基本原理就是给同一套 HTML 结构应用不同的样式，以达到不同的外观。</p><p>结合预编译样式语言，理想情况下，只要更改样式变量即可解锁不同的外观（收费皮肤的基本功）。那为什么不分开做成不同的主题呢？因为那不好玩（这逼装的可以）。贪玩的结果就是，三更半夜还在写作业，这是我获得的第一条人生真谛。由于 Scheme 之间需要共用一些内容，包括 HTML，CSS 以及 JavaScript 这三个闻名于世的贱客。这就需要设计一套良好的机制来降低开发与维护的成本，而这正是 NexT 所欠缺的。所以简单来说，三套 Scheme 加上各自的 Mobile 版本，也就意味着一次修改需要测试六个版本。</p><p>然后有了 Mist Scheme。如果不是我错觉，这款皮肤更受欢迎（果然收费皮肤有潜在的市场）。作为 NexT 第一款 Scheme，Mist 还是不负所望，如同夏日傍晚操场吹过的凉风，激起了一片裙子，噢，不是，秀发的飞扬（神马牌主题，宅家写博客常备良品）。</p><p>尽管没有一台单反设备，但这并不妨碍我想给 NexT 添加优雅地展示图片的想法。而这个过程一直不顺利，因为在易用性上确实很让人却步。遇到不顺的事情，拖延症就发作这种事情我是不会到处乱说的。就在最近，放着<a href="https://github.com/iissnan/hexo-theme-next/issues" target="_blank" rel="external">一堆 Bugs</a>没抓的前提下，我又开坑写了一个新的双栏皮肤（说好的暗色 Scheme 呢）。那么，这款皮肤称为 Pisces，目标是清秀。嗯，只能说这么多了，说太多易食言（其实只想到这么多）。</p><p><img src="https://raw.githubusercontent.com/iissnan/notes/gh-pages/uploads/something-about-next/pisces-preview.png" alt></p><p>就念叨到此吧。前路漫漫，后会有期。</p><hr><p><strong> 文章系转载，<a href="https://notes.iissnan.com/2015/something-about-next/" target="_blank" rel="external">原文链接</a> </strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;NexT 主题&lt;/a&gt;快满一周岁了，值此之际，碎碎念一下（没有干货）。正如我在&lt;a href=&quot;http://v2ex.com/t/165661&quot;&gt;V2EX 分享&lt;/a&gt;时的介绍一样，NexT 的前身叫做 &lt;a href=&quot;https://github.com/iissnan/hexo-theme-notes&quot;&gt;Notes&lt;/a&gt;。在做 Notes 主题的时候，基于当时的需求出发点，从好听上来讲是简洁，不好听就是简陋（真直接，脸红）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/iissnan/notes/gh-pages/uploads/something-about-next/theme-next.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://neveryu.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://neveryu.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>husky+lint-staged助力团队编码规范</title>
    <link href="https://neveryu.github.io/2020/husky-lint-staged/"/>
    <id>https://neveryu.github.io/2020/husky-lint-staged/</id>
    <published>2020-06-09T21:25:24.000Z</published>
    <updated>2020-06-21T04:27:53.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解-githooks"><a href="#了解-githooks" class="headerlink" title="了解 githooks"></a>了解 githooks</h1><p>Git Hooks 就是在 Git 执行特定事件（如commit、push、receive等）时触发运行的脚本，类似于“钩子函数”，没有设置可执行的钩子将被忽略。</p><p>在项目的 <code>.git/hooks</code> 目录中，有一些 <code>.sample</code> 结尾的钩子示例脚本，如果想启用对应的钩子，只需手动删除后缀，即可。（删除某一个 hook 的后缀 <code>.sample</code> 即可启用该 hook 脚本，默认是不启用的。）</p><p>【但是，我们一般不去改动 <code>.git/hooks</code> 里面的文件，因为我们使用 husky 】</p><a id="more"></a><h1 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h1><ul><li>husky 的安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i husky -D --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>husky 在安装过程中会在 <code>.git/hooks</code> 文件夹中生成一系列的 <code>git hook</code> 脚本。</p><blockquote><p>需要注意的是：你要留意 husky 的安装信息，是否为你安装了 <code>git</code> 钩子。</p></blockquote><p>如果安装正确的话，可以看到 husky 会打印出如下消息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; node husky install</span><br><span class="line">husky &gt; setting up git hooks  </span><br><span class="line">husky &gt; <span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/husky-2.png" alt></p><p>但也有可能：</p><p><img src="/images/husky-1.png" alt><br>这个就是由于电脑 <code>node</code> 版本的原因，跳过了 Git 钩子安装，相当于是没有安装成功哦~</p><p>OK，假设你的 husky 安装是正常的，那么 husky 为你安装的 hooks 将会生效。这样我们在 <code>git commit</code> 的时候会触发 <code>pre-commit</code> 钩子从而触发到 huksy。</p><p>我们在 <code>package.json</code> 文件中配置 husky 的钩子需要执行的 命令 或 操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"husky"</span>: &#123;</span><br><span class="line">  <span class="string">"hooks"</span>: &#123;</span><br><span class="line">    <span class="string">"pre-commit"</span>: <span class="string">"echo \"git commit trigger husky pre-commit hook\" "</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，在 <code>git commit</code> 的时候就会看到 <code>pre-commit</code> 执行了。<br><img src="/images/husky-3.png" alt></p><p>从 1.0.0 开始，husky 的配置可以使用 <code>.huskyrc</code>、<code>.huskyrc.json</code>、<code>.huskyrc.js</code> 或 <code>husky.config.js</code> 文件</p><h2 id="钩子中执行多个命令"><a href="#钩子中执行多个命令" class="headerlink" title="钩子中执行多个命令"></a>钩子中执行多个命令</h2><ul><li><p>根据 npm script 的规则，使用 &amp;&amp;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"husky"</span>: &#123;</span><br><span class="line">  <span class="string">"hooks"</span>: &#123;</span><br><span class="line">    <span class="string">"pre-commit"</span>: <span class="string">"echo \"git commit trigger husky pre-commit hook\" &amp;&amp; npm run test"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果您更喜欢使用数组，建议的方法是在 <code>.huskyrc.js</code> 中定义它们</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = <span class="function"><span class="params">arr</span> =&gt;</span> arr.join(<span class="string">' &amp;&amp; '</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">'hooks'</span>: &#123;</span><br><span class="line">    <span class="string">'pre-commit'</span>: tasks([</span><br><span class="line">      <span class="string">'npm run lint'</span>,</span><br><span class="line">      <span class="string">'npm run test'</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="hook-拦截"><a href="#hook-拦截" class="headerlink" title="hook 拦截"></a>hook 拦截</h2><p>为了阻止提交，<code>pre-commit</code> 脚本必须以非零的退出代码退出。</p><p>如果您的提交未被阻止，请检查脚本退出代码。</p><p>当然 husky 不止能验证 <code>commit</code> ，也可以进行 <code>push</code> 等其他操作验证，这里就不一一举例了，具体可以参照 <a href="https://www.npmjs.com/package/husky" target="_blank" rel="external">npm husky</a> 。</p><hr><h1 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h1><p><code>lint-staged</code> 是一个在 git 暂存文件上（也就是被 <code>git add</code> 的文件）运行已配置的 linter（或其他）任务。<code>lint-staged</code> 总是将所有暂存文件的列表传递给任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"></span><br><span class="line"><span class="string">"lint-staged"</span>: &#123;</span><br><span class="line">  <span class="string">"src/**/*.&#123;js,vue&#125;"</span>: [</span><br><span class="line">    <span class="string">"prettier --write"</span>,</span><br><span class="line">    <span class="string">"eslint --cache --fix"</span>,</span><br><span class="line">    <span class="string">"git add"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 lint-staged 的配置是：在 git 的待提交的文件中，在 src 目录下的所有 <code>.js</code> <code>.vue</code> 都要执行三条命令。前两条一会儿说，后一条是将处理过的代码重新 add 到 git 中。</p><p>结合我们前面介绍的 husky，配合 husky 的 pre-commit 钩子，将会形成一个自动化工具链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"husky"</span>: &#123;</span><br><span class="line">  <span class="string">"hooks"</span>: &#123;</span><br><span class="line">    <span class="string">"pre-commit"</span>: <span class="string">"lint-staged"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"lint-staged"</span>: &#123;</span><br><span class="line">  <span class="string">"src/**/*.&#123;js,vue&#125;"</span>: [<span class="string">"prettier --write"</span>, <span class="string">"eslint --cache --fix"</span>, <span class="string">"git add"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p id="div-border-left-green">在 commit 之前，将暂存区的内容做一次 代码检查 和 代码美化，然后再添加到暂存区；然后再 commit，完美！！<br></p><p>从 v3.1 开始，您现在可以使用不同的方式进行 lint-staged 配置：</p><ul><li>lint-staged  在你的对象 package.json</li><li>.lintstagedrc  JSON或YML格式的文件</li><li>lint-staged.config.js  JS格式的文件</li><li>使用 –config 或 -c 标志传递配置文件</li></ul><h1 id="mrm"><a href="#mrm" class="headerlink" title="mrm"></a>mrm</h1><p><a href="https://github.com/sapegin/mrm" target="_blank" rel="external">mrm</a> 是一个自动化工具。<span id="inline-purple">推荐</span></p><p>它将根据 package.json 依赖项中的代码质量工具来安装和配置 husky 和 lint-staged，因此请确保在此之前安装并配置所有代码质量工具，如 Prettier 和 ESlint</p><p>安装 mrm 并执行 lint-staged 任务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i mrm -D --registry=https://registry.npm.taobao.org</span><br><span class="line">npx mrm lint-staged</span><br></pre></td></tr></table></figure></p><p><a href="https://mrm.js.org/" target="_blank" rel="external">mrm 文档、mrm api doc</a></p><h1 id="关于-prettier-的问题"><a href="#关于-prettier-的问题" class="headerlink" title="关于 prettier 的问题"></a>关于 prettier 的问题</h1><p>prettier 是一个很好的格式化代码的插件，但对已经有一定迭代完成度的代码不推荐使用。使用该插件后，它会将原有的代码也进行格式化，造成很多不可知的问题，我就是前车之鉴，使用 prettier 后，原本已经没有 eslint 问题的代码，又多出了更多的不知道什么原因的报错，只能将代码回退处理。</p><p>所以，这也就是我们为什么在 <code>lint-staged</code> 中，执行 <code>prettier</code> 的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;了解-githooks&quot;&gt;&lt;a href=&quot;#了解-githooks&quot; class=&quot;headerlink&quot; title=&quot;了解 githooks&quot;&gt;&lt;/a&gt;了解 githooks&lt;/h1&gt;&lt;p&gt;Git Hooks 就是在 Git 执行特定事件（如commit、push、receive等）时触发运行的脚本，类似于“钩子函数”，没有设置可执行的钩子将被忽略。&lt;/p&gt;
&lt;p&gt;在项目的 &lt;code&gt;.git/hooks&lt;/code&gt; 目录中，有一些 &lt;code&gt;.sample&lt;/code&gt; 结尾的钩子示例脚本，如果想启用对应的钩子，只需手动删除后缀，即可。（删除某一个 hook 的后缀 &lt;code&gt;.sample&lt;/code&gt; 即可启用该 hook 脚本，默认是不启用的。）&lt;/p&gt;
&lt;p&gt;【但是，我们一般不去改动 &lt;code&gt;.git/hooks&lt;/code&gt; 里面的文件，因为我们使用 husky 】&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="husky" scheme="https://neveryu.github.io/tags/husky/"/>
    
      <category term="lint-staged" scheme="https://neveryu.github.io/tags/lint-staged/"/>
    
  </entry>
  
  <entry>
    <title>人到中年</title>
    <link href="https://neveryu.github.io/2019/mid-age/"/>
    <id>https://neveryu.github.io/2019/mid-age/</id>
    <published>2019-10-09T19:25:24.000Z</published>
    <updated>2021-10-28T14:33:55.509Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本来文章起名是叫“中年危机”的。思考了一下觉得不妥，“中年”不一定危机呢。“人到中年”像是一句还没说完的话，人到中年会怎么样呢？不同的人有不同的答案，把这个思考留给大家吧。</p></blockquote><p>你觉得 人到中年 应该是怎么样的生活和状态呢？</p><p>我不是一个喜欢喜欢贩卖焦虑的人，甚至很讨厌。因为生活已经很难了；</p><p>但这个世界，这个社会，这个环境，周边的人，总会漫不经心的触碰到你。</p><p>要对未来充满自信和希望。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本来文章起名是叫“中年危机”的。思考了一下觉得不妥，“中年”不一定危机呢。“人到中年”像是一句还没说完的话，人到中年会怎么样呢？不同的人有不同的答案，把这个思考留给大家吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你觉得 人到中年 应该是怎么样的
      
    
    </summary>
    
      <category term="综合" scheme="https://neveryu.github.io/categories/%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="essay" scheme="https://neveryu.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>基于Vue、ElementUI的换肤解决方案</title>
    <link href="https://neveryu.github.io/2019/vue-element-change-theme/"/>
    <id>https://neveryu.github.io/2019/vue-element-change-theme/</id>
    <published>2019-06-30T19:25:24.000Z</published>
    <updated>2019-10-08T14:54:48.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>换肤这个功能，不能算是很常见，但是也是有需求的，所以这里提供几种前端的换肤解决方案，供大家参考。</p><p>本文将介绍几种基于Vue、Element-UI的换肤实现方案，力争通俗易懂，易上手，希望大家喜欢~</p><a id="more"></a><h1 id="方案一、使用全局的样式覆盖（前端通用）"><a href="#方案一、使用全局的样式覆盖（前端通用）" class="headerlink" title="方案一、使用全局的样式覆盖（前端通用）"></a>方案一、使用全局的样式覆盖（前端通用）</h1><blockquote><p>这个应该是最常见，也是大家最容易想到的，也是最容易实现的一种方案。</p></blockquote><p>我们单独写一份样式表（css 文件 <a href="https://github.com/Neveryu/vue-cms/blob/master/src/assets/custom-theme/science-blue.css" target="_blank" rel="external">深空蓝.css</a>），以一个特定的命名开头（比如 <code>.blue-theme</code>），然后在这个 css 文件中，完成我们第二套皮肤的样式代码，然后当我们点击换肤的时候，就将 <code>blue-theme</code> 这个 <code>class</code> 添加到 <code>body</code> 标签中，那么这个时候，我们的换肤效果就出来了。</p><p><img src="https://img-blog.csdnimg.cn/20190904142928156.gif" alt="在这里插入图片描述"></p><p>当我们这里点击深空蓝的时候，将 class <code>science-blue</code> 添加到 <code>body</code> 上，点击青铜绿的时候，就将 <code>science-blue</code> 去掉，因为我们默认的就是青铜绿。</p><h1 id="方案二、自定义自己的Element-ui配色"><a href="#方案二、自定义自己的Element-ui配色" class="headerlink" title="方案二、自定义自己的Element-ui配色"></a>方案二、自定义自己的Element-ui配色</h1><p>默认的 Element 的配色是：</p><font color="#409EFF" size="4"><strong>蓝 色</strong></font><br><font color="#67C23A" size="4"><strong>绿 色</strong></font><br><font color="#E6A23C" size="4"><strong>橙 色</strong></font><br><font color="#F56C6C" size="4"><strong>红 色</strong></font><br><font color="#909399" size="4"><strong>灰 色</strong></font><p>Element-UI 还提供了了一个自定义的 <a href="https://github.com/ElementUI/element-theme" target="_blank" rel="external">配色工具</a> 以及 <a href="https://element.eleme.cn/#/zh-CN/theme/preview" target="_blank" rel="external">配置页面</a>，通过这个工具或者这个页面，我们可以自定义上面五种主色调以及辅助色。</p><p><img src="https://img-blog.csdnimg.cn/20190831135330563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feXVkb25n,size_16,color_FFFFFF,t_70" alt></p><p>配好以后，如果是工具就生成，如果是网页就下载。得到一个样式文件，这就是我们配置好的主题样式文件。<br><img src="https://img-blog.csdnimg.cn/2019083114454182.png" alt></p><p>保持 <code>css</code>文件与 <code>fonts</code> 目录的关系不变（ps：这点很重要），将其放入我们的项目中。（你可以将这个<code>css</code> 文件改成你喜欢的名字，比如我改成了叫：<code>theme-summer.css</code>）<br><img src="https://img-blog.csdnimg.cn/20190831144837820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feXVkb25n,size_16,color_FFFFFF,t_70" alt></p><p>然后在我们项目的 <code>main.js</code> 中，注释掉 <code>Element-UI</code> 的原来 css 文件引入，引入我们刚才放进项目中的 css 文件。<br><img src="https://img-blog.csdnimg.cn/2019083115045758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feXVkb25n,size_16,color_FFFFFF,t_70" alt><br>这个时候，项目中关于 Element-UI 的颜色，就变成了刚才我们自定义配置的颜色配色了。（<font color="#7ed321">下面是我自定义的一套颜色，你们觉得如何？</font>）</p><p><img src="https://img-blog.csdnimg.cn/20190831175858923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feXVkb25n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>但是，你发现没，这样只是将我们项目中的 Element-UI 的默认配色改成我们想要的；但是我们要做的是换肤功能，希望颜色是可以切换的。</strong></p><p><img src="https://img-blog.csdnimg.cn/2019083117114450.png" alt></p><p>所以，我们还是用上面的方法，给这个生成的css文件里面的每一个 <code>css</code> 样式加上一个独特的命名前缀，然后换肤的时候，就将这个 <code>class</code> 添加到 <code>body</code> 上面，如此一来，也能实现很丰富的换肤功能（因为我们可以自己配很多套好看的配色）</p><p><strong>现在摆在眼前的一个需要解决的问题是：这个 <code>css</code> 文件加命名空间怎么加？</strong><br><img src="https://img-blog.csdnimg.cn/2019083117211126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feXVkb25n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们看一下这个工具生成的，或者 <a href="https://element.eleme.cn/#/zh-CN/theme/preview" target="_blank" rel="external">配置页面</a> 导出的这个 css 文件，混淆压缩的代码，手动给每一个样式外面包裹一个 class 来做命名空间是不现实的，所以这里要用到一个 <code>gulp</code> 插件 <code>gulp-css-wrap</code> ，可以帮助我们完成这个结果。</p><p>首先：<br><code>npm i gulp gulp-clean-css gulp-css-wrap -D</code></p><p>然后，编写 <code>gulpfile.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gulpfile.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"><span class="keyword">var</span> cleanCSS = <span class="built_in">require</span>(<span class="string">'gulp-clean-css'</span>)</span><br><span class="line"><span class="keyword">var</span> cssWrap = <span class="built_in">require</span>(<span class="string">'gulp-css-wrap'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> customThemeName = <span class="string">'.theme-summer'</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src( path.resolve(<span class="string">'./index.css'</span>))</span><br><span class="line">    .pipe(cssWrap(&#123;<span class="attr">selector</span>: customThemeName&#125;))</span><br><span class="line">    .pipe(cleanCSS())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后运行 <code>gulp</code></p><p>这样就得到了一个以 <code>.theme-summer</code> 为命名空间的自定义主题了。</p><p>加完以后，我们按照前面介绍的切换 <code>body</code> 元素的 <code>class</code> 的方法，就可以实现皮肤切换的功能了。</p><p><img src="https://img-blog.csdnimg.cn/20190904143459163.gif" alt></p><h1 id="方案三、快速改变网站颜色"><a href="#方案三、快速改变网站颜色" class="headerlink" title="方案三、快速改变网站颜色"></a>方案三、快速改变网站颜色</h1><p>依据 Element 官网所介绍，Element 使用 SCSS 编写，如果你的项目也使用了 SCSS，那么可以直接在项目中改变 Element 的样式变量。新建一个 <code>element-variables.scss</code> 样式文件。（温馨提示：请确保你安装了 <code>node-sass</code> 与 <code>sass-loader</code>）</p><p><code>element-variables.scss</code> 文件，这里就不贴出来了，具体可以看这里：<a href="https://github.com/Neveryu/vue-cms/blob/master/src/element-variables.scss" target="_blank" rel="external">element-variables.scss</a>，这个文件里面定义了很多颜色变量</p><p>这种方法使用起来是简单的，你只需将其引入<br><img src="https://img-blog.csdnimg.cn/20190831181453850.png" alt="在这里插入图片描述"><br>修改里面的颜色变量即可生效。<br><img src="https://img-blog.csdnimg.cn/20190831181844187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feXVkb25n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这种方法是快捷的，修改几个颜色变量即可生效。（然后就可以部署啦~）</p><font color="red">这里有一个问题，如何在 js 中修改这个 <code>element-variables.scss</code> 文件里面的变量？如果可以实现，那么就可以实现实时动态换色了。</font><blockquote><p>补充说明： js 修改 scss 变量是有方案的，但是在我们项目中无法做到动态换颜色，为什么呢？因为我们项目中所有的 css 预编译语言（sass,less,stylus）最终都会编译成 css；也就是说，打包后的项目中只有编译后的 css 文件。那么你 js 改 scss 变量的方法在打包后的项目中是不起作用的。</p></blockquote><h1 id="方案四、实时更换主色调"><a href="#方案四、实时更换主色调" class="headerlink" title="方案四、实时更换主色调"></a>方案四、实时更换主色调</h1><font color="red">前面已经介绍了几种方法可以做到换肤，但都是在我们的限定提供的几个皮肤范围内换肤；但我们有一个需求是，弹出一个颜色选择器，然后我们选了什么颜色，页面的主色调就立马改成什么颜色。</font><p><code>ElementUI</code> 官网中有实现动态换肤，它能让用户自定义颜色值，而且展示效果也更加优雅。 我们来看看他是怎么实现的(这里引用的是官方的 <a href="https://github.com/ElemeFE/element/issues/3054" target="_blank" rel="external">实现解释</a>)</p><ul><li>获取当前版本的 <code>Element-UI</code> 的样式文件（在线 <code>XHR</code> 获取）</li><li>根据用户选择的主题色，生成一系列对应的颜色（比如，选择绿色，生成不同程度的浅绿，深绿…）</li><li>颜色替换（用刚刚生成的颜色来替换样式文件中的颜色）</li><li>直接在页面上加 <code>style</code> 标签，把生成的样式填进去</li></ul><font color="#1a6">我们一起来看一下技术实现细节吧，强烈建议你打开代码一起来看： <a href="https://github.com/Neveryu/vue-cms/blob/master/src/views/theme/index.vue#L167-L297" target="_blank" rel="external">https://github.com/Neveryu/vue-cms/blob/master/src/views/theme/index.vue#L167-L297</a>）</font><p>1、首先我们需要拿到通过 package.json 拿到 <code>element-ui</code> 的版本号，根据该版本号去请求相应的样式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有chalk就是第一次换颜色，需要远程获取css文件，赋值给chalk</span></span><br><span class="line"><span class="comment">// 后续的换颜色操作，就不用远程获取了</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.chalk) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`https://unpkg.com/element-ui@<span class="subst">$&#123;version&#125;</span>/lib/theme-chalk/index.css`</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.getCSSString(url, <span class="string">'chalk'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>getCSSString</code> 方法是一个常用 <code>XHR</code>，用来获取远程 <code>css</code> 资源文件。</p><p>2、根据用户选择的颜色，生成相应的颜色<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入一个颜色的HEX，得到这个颜色的深浅颜色数组</span></span><br><span class="line"><span class="comment"> * 我们知道，我们默认的主色调蓝色，在实际使用中，还需要对应的浅蓝和深蓝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[string]]&#125;</span> </span>theme [color]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;[array]&#125;</span>       </span>[对应的深浅颜色数组]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getThemeCluster(theme) &#123;</span><br><span class="line">    <span class="comment">// 具体看代码，这里就不写了</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、颜色替换<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 更新样式 - 使用新的颜色变量替换之前的 */</span></span><br><span class="line">updateStyle(style, oldCluster, newCluster) &#123;</span><br><span class="line">  <span class="keyword">let</span> newStyle = style</span><br><span class="line">  oldCluster.forEach(<span class="function">(<span class="params">color, index</span>) =&gt;</span> &#123;</span><br><span class="line">    newStyle = newStyle.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(color, <span class="string">'ig'</span>), newCluster[index])</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newStyle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、在页面上加 <code>style</code> 标签，把生成的样式填进去<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> styleTag = <span class="built_in">document</span>.getElementById(id)</span><br><span class="line"><span class="keyword">if</span> (!styleTag) &#123;</span><br><span class="line">  styleTag = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>)</span><br><span class="line">  styleTag.setAttribute(<span class="string">'id'</span>, id)</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(styleTag)</span><br><span class="line">&#125;</span><br><span class="line">styleTag.innerText = newStyle</span><br></pre></td></tr></table></figure></p><p>第一次换颜色的时候，需要创建一个 <code>style</code> 标签，添加到 <code>body</code> 中，后面的换颜色，就不用了。</p><p>OK啦，看下效果：</p><p><img src="https://img-blog.csdnimg.cn/20190904185728363.gif" alt="在这里插入图片描述"></p><p id="div-border-left-blue">【在线演示：<a href="https://neveryu.github.io/vue-cms/index.html">vue-cms</a>】<br>【源代码：<a href="https://github.com/Neveryu/vue-cms/blob/master/src/views/theme/index.vue" target="_blank" rel="external">github.com/Neveryu/vue-cms</a>】<br></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;换肤这个功能，不能算是很常见，但是也是有需求的，所以这里提供几种前端的换肤解决方案，供大家参考。&lt;/p&gt;
&lt;p&gt;本文将介绍几种基于Vue、Element-UI的换肤实现方案，力争通俗易懂，易上手，希望大家喜欢~&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://neveryu.github.io/tags/JavaScript/"/>
    
      <category term="Vue" scheme="https://neveryu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>【转】如何优雅处理前端异常</title>
    <link href="https://neveryu.github.io/2019/js-exception-handing/"/>
    <id>https://neveryu.github.io/2019/js-exception-handing/</id>
    <published>2019-04-30T19:25:24.000Z</published>
    <updated>2019-05-17T14:12:45.148Z</updated>
    
    <content type="html"><![CDATA[<p>前端一直是距离用户最近的一层，随着产品的日益完善，我们会更加注重用户体验，而前端异常却如鲠在喉，甚是烦人。</p><h1 id="一、为什么要处理异常？"><a href="#一、为什么要处理异常？" class="headerlink" title="一、为什么要处理异常？"></a>一、为什么要处理异常？</h1><p id="div-border-left-green">异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。</p><p>1.增强用户体验；<br>2.远程定位问题；<br>3.未雨绸缪，及早发现问题；<br>4.无法复线问题，尤其是移动端，机型，系统都是问题；<br>5.完善的前端方案，前端监控系统；</p><a id="more"></a><p>对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p><h1 id="二、需要处理哪些异常？"><a href="#二、需要处理哪些异常？" class="headerlink" title="二、需要处理哪些异常？"></a>二、需要处理哪些异常？</h1><p>对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：</p><ul><li>JS 语法错误、代码异常</li><li>AJAX 请求异常</li><li>静态资源加载异常</li><li>Promise 异常</li><li>Iframe 异常</li><li>跨域 Script error</li><li>崩溃和卡顿</li></ul><p id="div-border-left-yellow">下面我会针对每种具体情况来说明如何处理这些异常。</p><h1 id="三、Try-Catch-的误区"><a href="#三、Try-Catch-的误区" class="headerlink" title="三、Try-Catch 的误区"></a>三、Try-Catch 的误区</h1><p id="div-border-top-blue"><code>try-catch</code> 只能捕获到 <font color="red"><strong>同步</strong></font> 的运行时错误，对 <font color="red">语法</font> 和 <font color="red">异步</font> 错误却无能为力，捕获不到。【不能捕获XHR，AJAX的异常】</p><p>1.同步运行时错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'jartto'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(nam);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： <span class="built_in">ReferenceError</span>: nam is not defined at &lt;anonymous&gt;:<span class="number">3</span>:<span class="number">15</span></span><br></pre></td></tr></table></figure></p><p>2.不能捕获到语法错误，我们修改一下代码，删掉一个单引号：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'jartto;</span></span><br><span class="line"><span class="string">  console.log(nam);</span></span><br><span class="line"><span class="string">&#125; catch(e) &#123;</span></span><br><span class="line"><span class="string">  console.log('</span>捕获到异常：<span class="string">',e);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">SyntaxError</span>: Invalid or unexpected token</span><br></pre></td></tr></table></figure></p><blockquote><font color="#0e8a16">不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境吧。?</font></blockquote><p>3.异步错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="literal">undefined</span>.map(<span class="function"><span class="params">v</span> =&gt;</span> v);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看看日志：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">TypeError</span>: Cannot read property <span class="string">'map'</span> <span class="keyword">of</span> <span class="literal">undefined</span> at setTimeout (<span class="xml"><span class="tag">&lt;<span class="name">anonymous</span>&gt;</span>:3:11)</span></span><br></pre></td></tr></table></figure></p><p>并没有捕获到异常，这是需要我们特别注意的地方。<font color="#b60205">【try catch 无法捕获异步异常】</font></p><h1 id="四、window-onerror-不是万能的"><a href="#四、window-onerror-不是万能的" class="headerlink" title="四、window.onerror 不是万能的"></a>四、window.onerror 不是万能的</h1><p>当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 <code>window.onerror()</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;String&#125;</span>  </span>message    错误信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;String&#125;</span>  </span>source    出错文件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;Number&#125;</span>  </span>lineno    行号</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;Number&#125;</span>  </span>colno    列号</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;Object&#125;</span>  </span>error  Error对象（对象）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.首先试试同步运行时错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line"><span class="comment">// message：错误信息（字符串）。</span></span><br><span class="line"><span class="comment">// source：发生错误的脚本URL（字符串）</span></span><br><span class="line"><span class="comment">// lineno：发生错误的行号（数字）</span></span><br><span class="line"><span class="comment">// colno：发生错误的列号（数字）</span></span><br><span class="line"><span class="comment">// error：Error对象（对象）</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line">Jartto;</span><br></pre></td></tr></table></figure></p><p>可以看到，我们捕获到了异常：<br><img src="/images/js-exception-handing-1.png" alt></p><p>2.再试试语法错误呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'Jartto</span></span><br></pre></td></tr></table></figure></p><p>控制台打印出了这样的异常：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">SyntaxError</span>: Invalid or unexpected token</span><br></pre></td></tr></table></figure></p><p id="div-border-top-red">什么，竟然没有捕获到语法错误？!!</p><p>3.怀着忐忑的心，我们最后来试试异步运行时错误：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  Jartto;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>控制台输出了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： &#123;<span class="attr">message</span>: <span class="string">"Uncaught ReferenceError: Jartto is not defined"</span>, </span><br><span class="line">  source: <span class="string">"http://127.0.0.1:8001/"</span>, </span><br><span class="line">  lineno: <span class="number">36</span>, <span class="attr">colno</span>: <span class="number">5</span>, </span><br><span class="line">  error: <span class="built_in">ReferenceError</span>: Jartto is not defined at setTimeout (http:<span class="comment">//127.0.0.1:8001/:36:5)&#125;</span></span><br></pre></td></tr></table></figure></p><p>4.接着，我们试试网络请求异常的情况：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;img src="./</span>jartto.png<span class="string">"&gt;</span></span><br></pre></td></tr></table></figure></p><p id="div-border-left-red">我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。</p><p>补充一点：<code>window.onerror</code> 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 <code>Uncaught Error: xxxxx</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  Jartto;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台就不会再有这样的错误了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">ReferenceError</span>: Jartto is not defined</span><br><span class="line">    at setTimeout ((index):<span class="number">36</span>)</span><br></pre></td></tr></table></figure></p><font color="#ff8f00">需要注意：</font><ul><li>onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；</li><li>onerror 无法捕获语法错误；</li></ul><p id="div-border-top-red">到这里基本就清晰了：在实际的使用过程中，<code>onerror</code> 主要是来捕获预料之外的错误，而 <code>try-catch</code> 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p><p id="div-border-left-yellow">问题又来了，捕获不到静态资源加载异常怎么办？</p><h1 id="五、window-addEventListener"><a href="#五、window-addEventListener" class="headerlink" title="五、window.addEventListener"></a>五、window.addEventListener</h1><p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 <code>onerror()</code> 处理函数。这些 error 事件不会向上冒泡到 window ，不过（至少在 Firefox 中）能被单一的 <code>window.addEventListener</code> 捕获。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;scritp&gt;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>, (error) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, error);</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;img src="./</span>jartto.png<span class="string">"&gt;</span></span><br></pre></td></tr></table></figure></p><p>控制台输出：<br><img src="/images/js-exception-handing-2.png" alt></p><p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。</p><font color="red">需要注意：</font><ul><li>不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。</li><li>需要注意避免 addEventListener 重复监听。</li></ul><h1 id="六、Promise-Catch"><a href="#六、Promise-Catch" class="headerlink" title="六、Promise Catch"></a>六、Promise Catch</h1><p id="div-border-top-blue">在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。</p><p>没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。</p><p>解决方案： 为了防止有漏掉的 Promise 异常，建议在全局增加一个对 <code>unhandledrejection</code>的监听，用来全局监听 <code>Uncaught Promise Error</code>。使用方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"unhandledrejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>我们继续来尝试一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"unhandledrejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, e);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'promise error'</span>);</span><br></pre></td></tr></table></figure></p><p>可以看到如下输出：<br><img src="/images/js-exception-handing-3.png" alt></p><p>那如果对 Promise 不进行 catch 呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"unhandledrejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, e);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">'jartto: promise error'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>嗯，事实证明，也是会被正常捕获到的。</p><p>所以，正如我们上面所说，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 <code>unhandledrejection</code> 的监听，用来全局监听 <code>Uncaught Promise Error</code>。</p><p>补充一点：如果去掉控制台的异常显示，需要加上：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure></p><h1 id="七、VUE-errorHandler"><a href="#七、VUE-errorHandler" class="headerlink" title="七、VUE errorHandler"></a>七、VUE errorHandler</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = <span class="function">(<span class="params">err, vm, info</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'通过vue errorHandler捕获的错误'</span>);</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">  <span class="built_in">console</span>.error(vm);</span><br><span class="line">  <span class="built_in">console</span>.error(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、React-异常捕获"><a href="#八、React-异常捕获" class="headerlink" title="八、React 异常捕获"></a>八、React 异常捕获</h1><p>React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外，我们可以了解一下：<code>error boundary</code><br>UI 的某部分引起的 JS 错误不应该破坏整个程序，为了帮 React 的使用者解决这个问题，React 16 介绍了一种关于错误边界（error boundary)的新观念。</p><p id="div-border-left-red">需要注意的是： error boundaries 并不会捕捉下面这些错误。</p><p>1.事件处理器<br>2.异步代码<br>3.服务端的渲染代码<br>4.在 error boundaries 区域内的错误</p><p>我们来举一个小例子，在下面这个 <code>componentDIdCatch(error,info)</code> 里的类会变成一个 <code>error boundary</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// Display fallback UI</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// You can render any custom fallback UI</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们像使用普通组件那样使用它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  &lt;MyWidget /&gt;</span><br><span class="line">&lt;<span class="regexp">/ErrorBoundary&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>componentDidCatch()</code> 方法像 JS 的 <code>catch{}</code> 模块一样工作，但是对于组件，只有 class 类型的组件<code>( class component )</code>可以成为一个 <code>error boundaries</code>。</p><p>实际上，大多数情况下我们可以在整个程序中定义一个 <code>error boundary</code>组件，之后就可以一直使用它了！</p><h1 id="九、iframe-异常"><a href="#九、iframe-异常" class="headerlink" title="九、iframe 异常"></a>九、iframe 异常</h1><p>对于 iframe 的异常捕获，我们还得借力 <code>window.onerror</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个简单的例子可能如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"./iframe.html"</span> frameborder=<span class="string">"0"</span>&gt;&lt;<span class="regexp">/iframe&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  window.frames[0].onerror = function (message, source, lineno, colno, error) &#123;</span></span><br><span class="line"><span class="regexp">    console.log('捕获到 iframe 异常：',&#123;message, source, lineno, colno, error&#125;);</span></span><br><span class="line"><span class="regexp">    return true;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p><h1 id="十、Script-error"><a href="#十、Script-error" class="headerlink" title="十、Script error"></a>十、Script error</h1><p>一般情况，如果出现 <code>script error</code> 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：</p><p id="div-border-left-blue">跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://jartto.wang/main.js"</span> crossorigin&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>或者动态去添加 js 脚本：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.crossOrigin = <span class="string">'anonymous'</span>;</span><br><span class="line">script.src = url;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure></p><p id="div-border-left-yellow">特别注意，服务器端需要设置：Access-Control-Allow-Origin </p><p>此外，我们也可以试试这个 - <a href="https://juejin.im/post/5c00a405f265da610e7fd024" target="_blank" rel="external">解决 Script Error 的另类思路</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originAddEventListener = EventTarget.prototype.addEventListener;</span><br><span class="line">EventTarget.prototype.addEventListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> wrappedListener = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> listener.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> originAddEventListener.call(<span class="keyword">this</span>, type, wrappedListener, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下：</p><ul><li>改写了 EventTarget 的 addEventListener 方法；</li><li>对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；</li><li>浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；</li><li>重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；</li></ul><p>利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> originAddEventListener = EventTarget.prototype.addEventListener;</span><br><span class="line">   EventTarget.prototype.addEventListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener, options</span>) </span>&#123;</span><br><span class="line">+    <span class="comment">// 捕获添加事件时的堆栈</span></span><br><span class="line">+    <span class="keyword">const</span> addStack = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Event (<span class="subst">$&#123;type&#125;</span>)`</span>).stack;</span><br><span class="line">     <span class="keyword">const</span> wrappedListener = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> listener.apply(<span class="keyword">this</span>, args);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">+        <span class="comment">// 异常发生时，扩展堆栈</span></span><br><span class="line">+        err.stack += <span class="string">'\n'</span> + addStack;</span><br><span class="line">         <span class="keyword">throw</span> err;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> originAddEventListener.call(<span class="keyword">this</span>, type, wrappedListener, options);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure></p><h1 id="十一、崩溃和卡顿"><a href="#十一、崩溃和卡顿" class="headerlink" title="十一、崩溃和卡顿"></a>十一、崩溃和卡顿</h1><p>卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？</p><blockquote><p>崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。</p></blockquote><p>1.利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。<br>不错的文章，推荐阅读：<a href="http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/" target="_blank" rel="external">Logging Information on Browser Crashes</a>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  sessionStorage.setItem(<span class="string">'good_exit'</span>, <span class="string">'pending'</span>);</span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      sessionStorage.setItem(<span class="string">'time_before_crash'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().toString());</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'beforeunload'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  sessionStorage.setItem(<span class="string">'good_exit'</span>, <span class="string">'true'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span>(sessionStorage.getItem(<span class="string">'good_exit'</span>) &amp;&amp;</span><br><span class="line">  sessionStorage.getItem(<span class="string">'good_exit'</span>) !== <span class="string">'true'</span>) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      insert crash logging code here</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  alert(<span class="string">'Hey, welcome back from your crash, looks like you crashed on: '</span> + sessionStorage.getItem(<span class="string">'time_before_crash'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.基于以下原因，我们可以使用 <code>Service Worker</code> 来实现 <a href="https://juejin.im/entry/5be158116fb9a049c6434f4a?utm_source=gold_browser_extension" target="_blank" rel="external">网页崩溃的监控</a>：</p><ul><li>Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；</li><li>Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；</li><li>网页可以通过 <code>navigator.serviceWorker.controller.postMessage</code> API 向掌管自己的 SW 发送消息。</li></ul><h1 id="十二、错误上报"><a href="#十二、错误上报" class="headerlink" title="十二、错误上报"></a>十二、错误上报</h1><p>1.通过 Ajax 发送数据<br>因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。</p><p>2.动态创建 img 标签的形式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">report</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reportUrl = <span class="string">'http://jartto.wang/report'</span>;</span><br><span class="line">  <span class="keyword">new</span> Image().src = <span class="string">`<span class="subst">$&#123;reportUrl&#125;</span>?logs=<span class="subst">$&#123;error&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Reporter.send = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只采集 30%</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Math</span>.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">    send(data)      <span class="comment">// 上报错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。<font color="red">【这个随机数用的不错！】</font></p><h1 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h1><p id="div-border-left-yellow">回到我们开头提出的那个问题，如何优雅的处理异常呢？</p><p>1.可疑区域增加 Try-Catch<br>2.全局监控 JS 异常 window.onerror<br>3.全局监控静态资源异常 window.addEventListener<br>4.捕获没有 Catch 的 Promise 异常：unhandledrejection<br>5.VUE errorHandler 和 React componentDidCatch<br>6.监控网页崩溃：window 对象的 load 和 beforeunload<br>7.跨域 crossOrigin 解决</p><p>其实很简单，正如本文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。</p><p><a href="http://jartto.wang/2018/11/20/js-exception-handling/" target="_blank" rel="external">原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端一直是距离用户最近的一层，随着产品的日益完善，我们会更加注重用户体验，而前端异常却如鲠在喉，甚是烦人。&lt;/p&gt;
&lt;h1 id=&quot;一、为什么要处理异常？&quot;&gt;&lt;a href=&quot;#一、为什么要处理异常？&quot; class=&quot;headerlink&quot; title=&quot;一、为什么要处理异常？&quot;&gt;&lt;/a&gt;一、为什么要处理异常？&lt;/h1&gt;&lt;p id=&quot;div-border-left-green&quot;&gt;异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。&lt;/p&gt;

&lt;p&gt;1.增强用户体验；&lt;br&gt;2.远程定位问题；&lt;br&gt;3.未雨绸缪，及早发现问题；&lt;br&gt;4.无法复线问题，尤其是移动端，机型，系统都是问题；&lt;br&gt;5.完善的前端方案，前端监控系统；&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://neveryu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你 Vue 服务端渲染</title>
    <link href="https://neveryu.github.io/2019/vue-ssr/"/>
    <id>https://neveryu.github.io/2019/vue-ssr/</id>
    <published>2019-03-30T23:25:24.000Z</published>
    <updated>2023-04-04T08:43:05.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>在写这篇文章之前，我有写一篇 <a href="/2018/vue-prerender/">Vue 预渲染的教程</a> 以及 <a href="https://neveryu.github.io/prerender-website/index.html">在线示例</a>，有需要的可以看一下~</p><hr><font color="green">【下面开始 Vue 服务端渲染】</font><a id="more"></a><p>服务端渲染 = SSR = Server-Side Rendering</p><p><a href="https://ssr.vuejs.org/zh/" target="_blank" rel="external">Vue 服务器渲染</a> 可以说是我们学习 Vue 技术的最后一个环节了；也是上手难度稍为高一点的一个环节。</p><p>目前还没有发现很好的学习资料或者教程，文档也不是特别明白，这也导致了很多人没能拿下 vue 的 ssr。</p><p>所以就想着写一个曲线平滑，循序渐进，明了易懂的 <a href="https://github.com/Neveryu/vue-ssr-lessons" target="_blank" rel="external">教程</a> 来帮助大家找到 Vue SSR 的感觉。</p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><font color="red">由于内容较多，如果只写一篇文章就想把 Vue SSR 介绍清晰透彻的话，我觉得不太现实；</font>所以就想着把一个完整的 Vue SSR 项目细分开来，每一个小节讲解一个知识点，这样效果应该会好一点吧。这个项目虽然不大，但已经包含了 Vue SSR 的所有内容。</p><p id="div-border-top-green">项目仓库：<a href="https://github.com/Neveryu/vue-ssr-lessons" target="_blank" rel="external">https://github.com/Neveryu/vue-ssr-lessons</a><br></p><p>1、<a href="https://github.com/Neveryu/vue-ssr-lessons" target="_blank" rel="external">这个教程</a> 分为 7 个小节，每个小节都是一个独立的可以运行的小项目，这样可以减少大家出错的概率（如果只给出最终的代码，那万一又跑不起来，岂不凉凉，影响大家学习的心情）；每个小节简单配备了 <strong>运行步骤</strong> 以及 <strong>简要说明</strong> 来帮助大家运行项目以及了解本节的知识点。</p><p><img src="/images/vue-ssr-1.png" alt></p><p>2、其次，每个小节都是在前一小节的基础上，继续补充写代码的，这样，大家对比就能知道，这一节具体增加了哪些代码，哪些内容；方便大家学习某一个小节的知识（如果笼统的一次性给出最终代码，这样在找代码之间逻辑关系时，比较吃力）</p><h1 id="章节介绍"><a href="#章节介绍" class="headerlink" title="章节介绍"></a>章节介绍</h1><p>第一节：一个最简单的服务端渲染原型（10 行代码）【难度：<i class="fa fa-star"></i>】<br>第二节：与服务器集成，使用 Express 作为服务器提供服务【难度：<i class="fa fa-star"></i>】<br>第三节：使用一个页面模版【难度：<i class="fa fa-star"></i>】<br>第四节：开发客户端与服务端入口文件，配置webpack【难度：<i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>】<br>第五节：使用vue-router来做路由【难度：<i class="fa fa-star"></i><i class="fa fa-star"></i>】<br>第六节：数据，vuex，状态容器【难度：<i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>】<br>第七节：增加一些额外的功能，完善项目【难度：<i class="fa fa-star"></i><i class="fa fa-star"></i>】</p><h1 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h1><p>1、建议你先看一遍 Vue SSR 的文档，<em>看不懂的地方不要慌，留个印象也行</em><br>2、学习这个课程的时候，打开 Vue SSR 的文档；找到当前这一小节对应文档中的文字介绍部分<br>3、如果你基础有点薄弱的话，不要太过于着急<br>4、不能保证所有人看一遍就能学会，但是能保证所有人，两遍能拿下<br>5、如果你能跟着动手敲的话，将会事半功倍</p><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p><strong>1、避免单例状态</strong><br>在 <code>app.js</code> 中，暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例。</p><p><a href="https://ssr.vuejs.org/zh/guide/structure.html#%E9%81%BF%E5%85%8D%E7%8A%B6%E6%80%81%E5%8D%95%E4%BE%8B" target="_blank" rel="external">相关文档</a></p><p><img src="/images/vue-ssr-2.png" alt></p><p><strong>2、配置webpack</strong><br><code>webpack</code> 配置文件包含：基本配置(base config)、客户端配置(client config)、服务器配置(server config)。<br>基本配置包含两个环境（客户端环境，服务器环境）共享的配置；然后客户端配置和服务器配置都会通过使用 <code>webpack-merge</code> 来简单的扩展基本配置。</p><p><a href="https://ssr.vuejs.org/zh/guide/build-config.html" target="_blank" rel="external">相关文档</a></p><blockquote><p>教程中的 webpack 相关的配置已经配置好了，你可以直接全部拿过来用就行了</p></blockquote><p><strong>3、createBundleRenderer</strong><br>我们在前三节使用的都是 <code>vue-server-renderer</code> 中的 <code>createRenderer</code> 方法；从第四节开始，我们使用的是 <code>createBundleRenderer</code>，所创建的 <code>bundle renderer</code>，用法和普通 <code>renderer</code> 相同。 <code>createBundleRenderer</code> 接收一个 <code>server bundle</code> 生成的特殊 <code>JSON</code> 文件。但是 <code>bundle renderer</code> 提供以下优点：</p><ul><li>内置的 <code>source map</code> 支持（在 <code>webpack</code> 配置中使用 <code>devtool: &#39;source-map&#39;</code>）</li><li>在开发环境甚至部署过程中热重载（通过读取更新后的 <code>bundle</code>，然后重新创建 <code>renderer</code> 实例）</li><li>关键 <code>CSS(critical CSS)</code> 注入（在使用 <code>*.vue</code> 文件时）：自动内联在渲染过程中用到的组件所需的 <code>CSS</code>。更多细节请查看 <code>CSS</code> 章节。</li><li>使用 <code>clientManifest</code> 进行资源注入：自动推断出最佳的预加载(<code>preload</code>)和预取(<code>prefetch</code>)指令，以及初始渲染所需的代码分割 <code>chunk</code>。</li></ul><p><a href="https://ssr.vuejs.org/zh/guide/bundle-renderer.html" target="_blank" rel="external">相关文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h1&gt;&lt;p&gt;在写这篇文章之前，我有写一篇 &lt;a href=&quot;/2018/vue-prerender/&quot;&gt;Vue 预渲染的教程&lt;/a&gt; 以及 &lt;a href=&quot;https://neveryu.github.io/prerender-website/index.html&quot;&gt;在线示例&lt;/a&gt;，有需要的可以看一下~&lt;/p&gt;
&lt;hr&gt;
&lt;font color=&quot;green&quot;&gt;【下面开始 Vue 服务端渲染】&lt;/font&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="https://neveryu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>使用 Travis CI 自动更新 GitHub Pages</title>
    <link href="https://neveryu.github.io/2019/travis-ci/"/>
    <id>https://neveryu.github.io/2019/travis-ci/</id>
    <published>2019-02-04T23:25:24.000Z</published>
    <updated>2019-03-23T07:15:47.739Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://travis-ci.org/" target="_blank" rel="external">Travis CI</a> 提供的是持续集成服务（Continuous Integration，简称 CI）。我们在软件开发过程中，有构建、测试、部署这些必不可少的步骤，而这些会花掉我们很多的时间。为了提高软件开发的效率，现在涌现了很多自动化工具。<a href="https://travis-ci.org/" target="_blank" rel="external">Travis CI</a> 是目前<a href="https://github.blog/2017-11-07-github-welcomes-all-ci-tools/" target="_blank" rel="external">市场份额</a>最大的一个，而且有很详细的文档以及可以和 Github 很好的对接。</p><a id="more"></a><p>Travis CI 还是很强大的，用好这个工具不仅可以提高效率，还能使开发流程更可靠和专业化。</p><p>就我写的 <a href="https://neveryu.github.io/web-bookmarks/">web-bookmarks</a> 这个项目来说的话，每次更改完都要手动部署到 GitHub Pages。</p><p>从最开始的手动构建部署：手动敲构建命令，然后手动推到 GitHub。(<em>重复的次数多了就显得很麻烦，出错的几率也会变大。</em>)</p><p>后来写了一个构建部署的脚本：每次开发完，再手动执行脚本，完成构建部署。</p><p>再到现在的使用 CI 自动更新：开发完，我只用将源码 push 到 GitHub 做版本管理，就 ok 了；Travis 监测到代码有变化，然后就会自动执行我们设定好的任务。【优秀～】</p><h1 id="一、什么是持续集成"><a href="#一、什么是持续集成" class="headerlink" title="一、什么是持续集成"></a>一、什么是持续集成</h1><p>Travis CI 提供的持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。</p><p>持续集成指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。</p><p id="div-border-top-purple">举一个例子：我们可以在我们的开源项目中，安排一个代码格式检查和测试的任务 <code>npm run test</code>，不管是自己提交代码，还是别人提交的 PR，Travis 监测到代码有新的内容，都会来执行这个任务。【不管代码写的怎样，格式一定不能乱～，哈哈😄】<br></p><p>持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。</p><h1 id="二、开始使用"><a href="#二、开始使用" class="headerlink" title="二、开始使用"></a>二、开始使用</h1><p>首先打开官方网站 <a href="https://travis-ci.org" target="_blank" rel="external">travis-ci.org</a>，然后使用 Github 账号登入 Travis CI，然后 Travis 中会列出你 Github 上面所有的仓库，以及你所属于的组织。</p><p>然后，勾选你需要 Travis 帮你自动构建的仓库，打开仓库旁边的开关，打开以后，Travis 就会监听这个仓库的所有变化了。</p><p><img src="/images/travis-ci-1.png" alt="travis-ci-1"></p><h1 id="三、-travis-yml"><a href="#三、-travis-yml" class="headerlink" title="三、.travis.yml"></a>三、.travis.yml</h1><p>Travis 要求项目的根目录下面，必须有一个 <code>.travis.yml</code> 文件。这是配置文件，指定了 Travis 的行为。该文件必须保存在 Github 仓库里面，一旦代码仓库有新的 <code>Commit</code>，Travis 就会去找这个文件，执行里面的命令。</p><p>所以呢，我们就可以在这个文件里，配置我们任务（Travis 监测到仓库有 <code>commit</code> 后会自动执行）。</p><p>一个简单的 <code>.travis.yml</code> 文件如下：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">script:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>所以呢，我在 <code>.travis.yml</code> 里，配置了一个执行脚本的任务；那么现在 Travis 监测到我仓库有 <code>commit</code> 后就会找到 <code>.travis.yml</code> 这个文件，然后就执行了我的那个脚本了。</p><h2 id="install-字段"><a href="#install-字段" class="headerlink" title="install 字段"></a>install 字段</h2><p><code>install</code> 字段用来指定安装脚本，如果有多个脚本，可以写成下面的形式。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">command1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">command2</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，如果 <code>command1</code> 失败了，整个构建就会停下来，不再往下进行<br>如果不需要安装，即跳过安装阶段，就直接设为 <code>true</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="script-字段"><a href="#script-字段" class="headerlink" title="script 字段"></a>script 字段</h2><p><code>script</code> 字段用来配置构建或者测试脚本，如果有多个脚本，可以写成下面的形式。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">command1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">command2</span></span><br></pre></td></tr></table></figure></p><p>注意，<code>script</code> 与 <code>install</code> 不一样，如果 <code>command1</code> 失败，<code>command2</code> 会继续执行。但是，整个构建阶段的状态是失败。</p><p>如果 <code>command2</code> 只有在 <code>command1</code> 成功后才能执行，就要写成下面这样。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">script:</span> <span class="string">command1</span> <span class="string">&amp;&amp;</span> <span class="string">command2</span></span><br></pre></td></tr></table></figure></p><h1 id="四、部署时面临的问题"><a href="#四、部署时面临的问题" class="headerlink" title="四、部署时面临的问题"></a>四、部署时面临的问题</h1><p id="div-border-left-red">现在脚本是由 Travis CI 来执行的，部署的时候，怎么让 Travis 有权限往 Github 提交代码呢？</p><p>Github 有提供一个 <a href="https://github.blog/2013-05-16-personal-api-tokens/" target="_blank" rel="external">Personal access tokens</a>，这个 Token 与 账号密码 以及 SSH Keys 同样具有 Github 写入能力。</p><p>前往 Github 帐号 Settings 页面，在左侧选择 <code>Personal Access Token</code>，然后在右侧面板点击 <code>“Generate new token”</code> 来新建一个 Token。需要注意的是，创建完的 Token 只有第一次可见，之后再访问就无法看见（只能看见他的名称），因此要保存好这个值。</p><p><img src="/images/travis-ci-2.png" alt="travis-ci-2"></p><p>那么，这个 Token 怎么使用呢。</p><h2 id="方案一、"><a href="#方案一、" class="headerlink" title="方案一、"></a>方案一、</h2><p>一个比较方便快捷的方式，是通过 Travis 网站，写在每个仓库的设置页面里，有一个 <code>Environment Variables</code> 的配置项，给我们的 Token 起一个名字 <code>gh_token</code> 添加进去。这样以来，脚本内部就可以使用这个环境变量了。<br><img src="/images/travis-ci-3.png" alt="travis-ci-1"><br>你可以在你脚本内部使用 <code>${gh_token}</code> 的形式来使用这个 Token 了。【当然了，你还可以添加其他的环境变量进去。】【<a href="https://docs.travis-ci.com/user/environment-variables" target="_blank" rel="external">官方文档在这里</a>】</p><p>使用 <code>Personal access tokens</code> 向 GitHub 提交代码的命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $&#123;GH_TOKEN&#125; 对应就是 Personal access tokens ， GH_TOKEN 是环境变量名</span></span><br><span class="line"><span class="comment"># $&#123;GH_REF&#125; 对应的是你的 Github 仓库地址，GH_REF 是变量名</span></span><br><span class="line">git push -f <span class="string">"https://<span class="variable">$&#123;GH_TOKEN&#125;</span>@<span class="variable">$&#123;GH_REF&#125;</span>"</span> master:gh-pages</span><br></pre></td></tr></table></figure></p><p id="div-border-left-green">这里需要注意的是：<br>1、GitHub 生成的这个 Token ，只有生成的时候可以看到明文，后面就看不到明文了，所以你使用的时候最好一次操作成功。<br>2、Travis CI 中添加 Token 时，记得用密文，要不然在 <code>build log</code> 中是可以被看到的。<br></p><h2 id="方案二、"><a href="#方案二、" class="headerlink" title="方案二、"></a>方案二、</h2><p>你还可以使用 Travis CI 提供的加密工具来加密我们的这个 Token。加密原理机制如下：</p><p><img src="/images/travis-encrypt.png" alt="travis-ci-encrypt"></p><p>首先，安装 Ruby 的包 <code>travis</code> 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Travis CI 命令行工具</span></span><br><span class="line">$ gem install travis</span><br></pre></td></tr></table></figure></p><p>然后，就可以用 <code>travis encrypt</code> 命令加密信息。<br>在项目的根目录下，执行下面的命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ travis encrypt name=secretvalue</span><br></pre></td></tr></table></figure></p><p>上面命令中，<code>gh_token</code> 是要加密的变量名，<code>secretvalue</code> 是要加密的变量值。执行以后，屏幕上会输出如下信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secure: &quot;... encrypted data ...&quot;</span><br></pre></td></tr></table></figure></p><p>现在，就可以把这一行加入 <code>.travis.yml</code> 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env:</span><br><span class="line">  global:</span><br><span class="line">    - GH_REF: github.com/Neveryu/xxxxx.git</span><br><span class="line">    - secure: <span class="string">"... entrypted data ..."</span></span><br></pre></td></tr></table></figure></p><p>然后，脚本里面就可以使用环境变量 <code>gh_token</code> 了，Travis 会在运行时自动对它解密。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $&#123;gh_token&#125; 对应就是 Personal access tokens ， gh_token 是环境变量名</span></span><br><span class="line"><span class="comment"># $&#123;GH_REF&#125; 对应的是你的 Github 仓库地址，GH_REF 是变量名</span></span><br><span class="line">git push -f <span class="string">"https://<span class="variable">$&#123;gh_token&#125;</span>@<span class="variable">$&#123;GH_REF&#125;</span>"</span> master:gh-pages</span><br></pre></td></tr></table></figure><p><code>travis encrypt</code> 命令的 <code>--add</code> 参数会把输出自动写入 <code>.travis.yml</code>，省掉了修改 <code>env</code> 字段的步骤。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ travis encrypt name=secretvalue --add</span><br></pre></td></tr></table></figure></p><p>详细信息请看<a href="https://docs.travis-ci.com/user/encryption-keys/" target="_blank" rel="external">官方文档</a></p><p id="div-border-top-red">可以参考我的 <a href="https://github.com/Neveryu/vue-cms" target="_blank" title="vue-cms">vue-cms</a> 这个项目中的 <code>.travis.yml</code> 文件</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="如何显示-Status-Image"><a href="#如何显示-Status-Image" class="headerlink" title="如何显示 Status Image"></a>如何显示 Status Image</h2><p><a href="https://travis-ci.org/Neveryu/web-bookmarks" target="_blank" rel="external"><img src="https://travis-ci.org/Neveryu/web-bookmarks.svg?branch=master" alt="Build Status"></a></p><p><img src="/images/travis-ci-4.png" alt="travis-ci-4"></p><h2 id="如何跳过自动构建"><a href="#如何跳过自动构建" class="headerlink" title="如何跳过自动构建"></a>如何跳过自动构建</h2><p>如果 commit 不想让 Travis 构建，那么就在 commit message 里加上 [ci skip] 就行了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"[ci skip] commit message"</span></span><br></pre></td></tr></table></figure></p><h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><p>如果遇到脚本权限不够的提示或者问题，你可以给你的脚本加上权限：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x deploy.sh</span><br></pre></td></tr></table></figure></p><p>或者在 <code>.travis.yml</code> 里加：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">chmod</span> <span class="string">u+x</span> <span class="string">deploy.sh</span></span><br></pre></td></tr></table></figure></p><h1 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h1><h2 id="Travis-CI-加密文件"><a href="#Travis-CI-加密文件" class="headerlink" title="Travis CI 加密文件"></a>Travis CI 加密文件</h2><p>如果要加密的是文件（比如私钥），Travis 提供了加密文件功能。<br>安装命令行客户端以后，使用下面的命令登入 Travis CI 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ travis login</span><br></pre></td></tr></table></figure></p><p>然后，进入项目的根目录，使用 <code>travis encrypt-file</code> 命令加密那些想要加密的文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ travis entrypt-file bacon.txt</span><br><span class="line"></span><br><span class="line">encrypting bacon.txt <span class="keyword">for</span> rkh/travis-encrypt-file-example</span><br><span class="line">storing result as bacon.txt.enc</span><br><span class="line">storing secure env variables <span class="keyword">for</span> decryption</span><br><span class="line"></span><br><span class="line">Please add the following to your build script (before_install stage <span class="keyword">in</span> your .travis.yml, <span class="keyword">for</span> instance):</span><br><span class="line"></span><br><span class="line">    openssl aes-256-cbc -K <span class="variable">$encrypted_0a6446eb3ae3_key</span> -iv <span class="variable">$encrypted_0a6446eb3ae3_key</span> -<span class="keyword">in</span> bacon.txt.enc -out bacon.txt -d</span><br><span class="line"></span><br><span class="line">Pro Tip: You can add it automatically by running with --add.</span><br><span class="line"></span><br><span class="line">Make sure to add bacon.txt.enc to the git repository.</span><br><span class="line">Make sure not to add bacon.txt to the git repository.</span><br><span class="line">Commit all changes to your .travis.yml.</span><br></pre></td></tr></table></figure></p><p>上面的代码对文件 <code>bacon.txt</code> 进行加密，加密后会生成 <code>bacon.txt.enc</code> ，该文件需要提交到代码库。此外，该命令还会生成一个环境变量 <code>$entrypted_0a6446eb3ae3_key</code>，保存密钥，储存在 Travis CI，文件解密时需要这个环境变量。你需要把解密所需的 <code>openssl</code> 命令，写在 <code>.travis.yml</code> 的 <code>before_install</code> 字段里面。这些都写在上面的命令行提示里面。</p><p><code>--add</code> 参数可以自动把环境变量写入 <code>.travis.yml</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ travis encrypt-file bacon.txt --add</span><br><span class="line">entrypting bacon.txt <span class="keyword">for</span> rkh/travis-encrypt-file-example</span><br><span class="line">storing result as bacon.txt.enc</span><br><span class="line">storing secure env variables <span class="keyword">for</span> decryption</span><br><span class="line"></span><br><span class="line">Make sure to add bacon.txt.enc to the git repository.</span><br><span class="line">Make sure not to add bacon.txt to the git repository.</span><br><span class="line">Commit all changes to your .travis.yml.</span><br></pre></td></tr></table></figure><p>详细信息请看<a href="https://docs.travis-ci.com/user/encrypting-files/" target="_blank" rel="external">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://travis-ci.org/&quot;&gt;Travis CI&lt;/a&gt; 提供的是持续集成服务（Continuous Integration，简称 CI）。我们在软件开发过程中，有构建、测试、部署这些必不可少的步骤，而这些会花掉我们很多的时间。为了提高软件开发的效率，现在涌现了很多自动化工具。&lt;a href=&quot;https://travis-ci.org/&quot;&gt;Travis CI&lt;/a&gt; 是目前&lt;a href=&quot;https://github.blog/2017-11-07-github-welcomes-all-ci-tools/&quot;&gt;市场份额&lt;/a&gt;最大的一个，而且有很详细的文档以及可以和 Github 很好的对接。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CI" scheme="https://neveryu.github.io/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-NexT搭建个人博客（六）</title>
    <link href="https://neveryu.github.io/2018/hexo-next-six/"/>
    <id>https://neveryu.github.io/2018/hexo-next-six/</id>
    <published>2018-10-15T15:25:24.000Z</published>
    <updated>2018-10-20T07:44:55.439Z</updated>
    
    <content type="html"><![CDATA[<p>在 hexo 中，我们如何使用自己自定义的 html 页面呢？</p><p>我们知道，在 hexo 中，我们使用的是 markdown 格式的文件，渲染出来的页面是有主题样式的。如果我们不希望我们的页面使用主题样式。那么需要在文件头部加一个 <code>layout: false</code> 的配置。</p><p><strong>使用 md 文件写文章时增加配置不使用 layout </strong></p><a id="more"></a><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我来试一下如何禁止解析html</span><br><span class="line">date: 2018-10-04 13:25:24</span><br><span class="line">categories: 综合</span><br><span class="line">tags: [综合]</span><br><span class="line">comments: false</span><br><span class="line">layout: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>这样，我们的文件就不会被主题渲染。</p><hr><p>其实在我们的 hexo 中，是可以直接写 html 文件的，不过也会被渲染，出来的页面还是有主题样式的。如果我们不想要这个主题样式，怎么做呢？</p><p><strong> 使用 <code>skip_render</code> </strong></p><p><code>skip_render</code> 跳过指定文件的渲染，您可使用 <a href="https://github.com/isaacs/node-glob" target="_blank" rel="external">glob 表达式</a> 来匹配路径。   </p><p><code>skip_render</code> 的配置在 <span id="inline-blue">站点配置文件</span> 中。</p><p>只有 <code>source</code> 目录下的文件才会发布到 <code>public</code>（能够在网络上访问到），因此 Hexo 只渲染 <code>source</code> 目录下的文件。<code>skip_render</code> 参数设置的路径是相对于 <code>source</code> 目录的路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: test.html</span><br></pre></td></tr></table></figure></p><p>注意，千万不要写成<code>/test.html</code>，这里只能填相对于source文件夹的相对路径。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 hexo 中，我们如何使用自己自定义的 html 页面呢？&lt;/p&gt;
&lt;p&gt;我们知道，在 hexo 中，我们使用的是 markdown 格式的文件，渲染出来的页面是有主题样式的。如果我们不希望我们的页面使用主题样式。那么需要在文件头部加一个 &lt;code&gt;layout: false&lt;/code&gt; 的配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用 md 文件写文章时增加配置不使用 layout &lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://neveryu.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://neveryu.github.io/tags/Hexo/"/>
    
      <category term="Next" scheme="https://neveryu.github.io/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Yarn安装与使用详细介绍</title>
    <link href="https://neveryu.github.io/2018/yarn/"/>
    <id>https://neveryu.github.io/2018/yarn/</id>
    <published>2018-07-19T19:25:24.000Z</published>
    <updated>2018-08-29T14:48:45.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 Node 生态系统中，依赖通常安装在项目的 <code>node_modules</code> 文件夹中。然而，这个文件的结构和实际依赖树可能有所区别，因为重复的依赖可以合并到一起。<code>npm</code> 客户端把依赖安装到 <code>node_modules</code> 目录的过程具有不确定性。这意味着当依赖的安装顺序不同时，<code>node_modules</code> 目录的结构可能会发生变化。这种差异可能会导致类似<font color="red">“我的电脑上可以运行，别的电脑上不行”</font>的情况，并且通常需要花费大量时间定为与解决。</p><blockquote><p>有时候就会遇到这种情况，完整可运行的项目上传到 git 上，别人 pull 下来以后，npm install 会报错。</p></blockquote><p><a href="https://github.com/yarnpkg/yarn" target="_blank" rel="external">Yarn</a> 一开始的主要目标是解决由于语义版本控制而导致的 npm 安装的不确定性问题。虽然可以用 <code>npm shrinkwrap</code> 来实现可预测的依赖关系树，但它并不是默认选项，而是取决于所有的开发人员指导并启用这个选项。</p><a id="more"></a><blockquote><p>npm 5+ 以后的版本加入了 package-lock.json 可以用来锁版本，package-lock.json 的名字，一看就懂，更清楚，但是不向后兼容。</p></blockquote><blockquote><p>npm-shrinkwrap.json 向后兼容 npm 2-4。</p></blockquote><p><font color="red">举个例子：</font><br>npm 对包引入顺序也十分的敏感，比如在一个空项目里执行以下命令：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install globule@<span class="number">0.1</span><span class="number">.0</span> -S</span><br><span class="line">npm install babel-generator@<span class="number">6.19</span><span class="number">.0</span> -S</span><br><span class="line">npm install babel-helper-define-map@<span class="number">6.18</span><span class="number">.0</span> -S</span><br></pre></td></tr></table></figure></p><p>我们这里安装了 3 个包都依赖于 lodash，不过 globule 依赖 <a href="mailto:lodash@1.0.3" target="_blank" rel="external">lodash@1.0.3</a>，另外另个依赖 <a href="mailto:lodash@4.x" target="_blank" rel="external">lodash@4.x</a>。<br>现在目录依赖结构如下：<br><img src="https://img-blog.csdn.net/20180824142908356?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feXVkb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="npm-package"></p><p>这是假设我们在项目里使用 lodash，但是忘记重新安装 lodash<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lodash = <span class="built_in">require</span>(<span class="string">'lodash'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(lodash.VERSION)  <span class="comment">// v1.0.3</span></span><br></pre></td></tr></table></figure></p><p>另一个同事获取项目代码，执行 <code>npm install</code>，这时的目录依赖结构里面，第一层依赖的 lodash 变成了 4.x 版本，这样就造成了依赖版本不一致的问题。而 yarn 则会保证无论怎样引入的顺序，目录依赖结构都是一致的，确保不会发生这样的BUG。</p><h1 id="什么是-Yarn"><a href="#什么是-Yarn" class="headerlink" title="什么是 Yarn"></a>什么是 Yarn</h1><p>Yarn 就是一个类似于 npm 的包管理工具，它是由 facebook 推出并开源。</p><p>与 npm 相比，yarn 有着众多的优势，主要的优势在于：速度快、离线模式、版本控制。</p><h2 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h2><p>npm 会等一个包完全安装完才跳到下一个包，但 yarn 会并行执行包，因此速度会快很多。</p><p>Yarn 会缓存它下载的每个包，所以无需重复下载。它还能并行化操作以最大化资源利用率，安装速度之快前所未有。</p><h2 id="离线模式"><a href="#离线模式" class="headerlink" title="离线模式"></a>离线模式</h2><p>之前安装过的包会被保存进缓存目录，以后安装就直接从缓存中复制过来，这样做的本质还是会提高安装下载的速度，避免不必要的网络请求。</p><h2 id="可靠可确定性"><a href="#可靠可确定性" class="headerlink" title="可靠可确定性"></a>可靠可确定性</h2><p>保证各平台依赖的一致性</p><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><p>力求网络资源最大利用化，让资源下载完美队列执行，避免大量的无用请求，下载失败会自动重新请求，避免整个安装过程失败</p><h2 id="扁平化模式"><a href="#扁平化模式" class="headerlink" title="扁平化模式"></a>扁平化模式</h2><p>对于不匹配的依赖版本的包创立一个独立的包，避免创建重复的。<br>对于多个包依赖同一个子包的情况，yarn 会尽量提取为同一个包，防止出现多处副本，浪费空间。</p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>npm 用下来比较强的一个痛点就是：当包的依赖层次比较深时，版本控制不够精确。会出现相同 package.json，但不同人的电脑上安装出不同版本的依赖包，出现类似<font color="red">“我的电脑上可以运行，别的电脑上不行”</font>的 bug 很难查找。你可以使用 <a href="https://docs.npmjs.com/cli/shrinkwrap" target="_blank" rel="external">npm-shrinkwrap</a> 来实现版本固化，版本信息会写入 npm-shrinkwrap.json 文件中，但它毕竟不是 npm 的标准配置。</p><p>而 yarn 天生就能实现版本固化。会生成一个类似 npm-shrinkwrap.json 的 yarn.lock 文件，而文件内会描述包自身的版本号，还会锁定所有它依赖的包的版本号：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"@babel/code-frame@7.0.0-beta.47"</span>:</span><br><span class="line">  version <span class="string">"7.0.0-beta.47"</span></span><br><span class="line">  resolved <span class="string">"https://registry.yarnpkg.com/@babel/code-frame/-/code-frame-7.0.0-beta.47.tgz#d18c2f4c4ba8d093a2bcfab5616593bfe2441a27"</span></span><br><span class="line">  dependencies:</span><br><span class="line">    <span class="string">"@babel/highlight"</span> <span class="string">"7.0.0-beta.47"</span></span><br></pre></td></tr></table></figure></p><p>yarn.lock 存储着你的每个包的确切依赖版本，能确保从本地开发到生产环境，所有机器上都有精确相同的依赖版本。</p><h2 id="其他关于-Yarn-的介绍"><a href="#其他关于-Yarn-的介绍" class="headerlink" title="其他关于 Yarn 的介绍"></a>其他关于 Yarn 的介绍</h2><p>我们在使用 Yarn 时，依然要访问 npm 仓库，但 Yarn 能够更快速地安装软件包和管理依赖关系，并且可以在跨机器或者无网络的安全环境中保持代码的一致性。</p><h1 id="Yarn-安装"><a href="#Yarn-安装" class="headerlink" title="Yarn 安装"></a>Yarn 安装</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>在 Yarn 中文网可以找到 window 下的三种安装方法：</p><p><img src="https://img-blog.csdn.net/20180824120236673?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feXVkb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="yarn-install"></p><p>不过我觉得这三种方法都不好用，快速好用的安装方法应该还是使用 npm 来安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure></p><p>关于为什么使用 <code>-g</code>，以及 <code>-g</code> 会带来哪来影响，这个可以看我的这篇文章：<a href="https://neveryu.github.io/2017/04/10/npm/">npm详细介绍</a>，里面详细介绍了为什么要使用 <code>-g</code>，以及 <code>-g</code> 的作用。</p><h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure><p>如果有报： <code>Please try running this command again as root/Administrator.</code>，可能就是权限不足，因此你需要切换到最高权限去执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line">npm install yarn -g</span><br></pre></td></tr></table></figure></p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用另一种初始化脚本的方法，可能就会比较简单一些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- -L https://yarnpkg.com/install.sh | bash</span><br></pre></td></tr></table></figure></p><h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>如果你的电脑上面已经安装了 Homebrew 的话，你可以通过 Homebrew 包管理器安装 Yarn<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install yarn</span><br></pre></td></tr></table></figure></p><h1 id="Yarn-换源"><a href="#Yarn-换源" class="headerlink" title="Yarn 换源"></a>Yarn 换源</h1><p>Yarn 源仓库包下载不稳定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查看 yarn 配置</span><br><span class="line">yarn config get registry</span><br><span class="line">或者</span><br><span class="line">yarn config list</span><br><span class="line"></span><br><span class="line">&gt; registry: &apos;https://registry.yarnpkg.com&apos;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装淘宝镜像</span><br><span class="line">yarn config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h1 id="Yarn-常用命令"><a href="#Yarn-常用命令" class="headerlink" title="Yarn 常用命令"></a>Yarn 常用命令</h1><ul><li><code>npm install</code> === <code>yarn</code>  —— install安装是默认行为</li><li><code>npm install taco --save</code> === <code>yarn add taco</code>  —— taco包立即被保存到 <code>package.json</code> 中。</li><li><code>npm uninstall taco --save</code> === <code>yarn remove taco</code></li><li><code>npm install taco --save-dev</code> === <code>yarn add taco --dev</code></li><li><code>npm update --save</code> === <code>yarn upgrade</code></li></ul><p>-</p><ul><li><code>npm install taco@latest --save</code> === <code>yarn add taco</code></li><li><code>npm install taco --global</code> === <code>yarn global add taco</code>  —— 一如既往，请谨慎使用 global 标记。</li></ul><blockquote><p>注意：使用yarn或yarn install安装全部依赖时是根据package.json里的”dependencies”字段来决定的</p></blockquote><p>-</p><ul><li><code>npm init</code> === <code>yarn init</code></li><li><code>npm init --yes/-y</code> === <code>yarn init --yes/-y</code></li><li><code>npm link</code> === <code>yarn link</code></li><li><code>npm outdated</code> === <code>yarn outdated</code></li><li><code>npm publish</code> === <code>yarn publish</code></li><li><code>npm run</code> === <code>yarn run</code></li><li><code>npm cache clean</code> === <code>yarn cache clean</code></li><li><code>npm login</code> === <code>yarn login</code></li><li><code>npm test</code> === <code>yarn test</code></li></ul><h2 id="Yarn-独有的命令"><a href="#Yarn-独有的命令" class="headerlink" title="Yarn 独有的命令"></a>Yarn 独有的命令</h2><ul><li><code>yarn licenses ls</code>  —— 允许你检查依赖的许可信息</li><li><code>yarn licenses generate</code>  —— 自动创建依赖免责声明 license</li><li><code>yarn why taco</code>  —— 检查为什么会安装 taco，详细列出依赖它的其他包</li><li><code>yarn why vuepress</code>  —— 检查为什么会安装 vuepress，详细列出依赖它的其他包</li></ul><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>Yarn 除了让安装过程变得更快与更可靠，还添加了一些额外的特性，从而进一步简化依赖管理的工作流。</p><ul><li>同时兼容 <code>npm</code> 与 <code>bower</code> 工作流，并支持两种软件仓库混合使用</li><li>可以限制已安装模块的协议，并提供方法输出协议信息</li><li>提供一套稳定的共有 JS API，用于记录构建工具的输出信息</li><li>可读、最小化、美观的 CLI 输出信息</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在 Node 生态系统中，依赖通常安装在项目的 &lt;code&gt;node_modules&lt;/code&gt; 文件夹中。然而，这个文件的结构和实际依赖树可能有所区别，因为重复的依赖可以合并到一起。&lt;code&gt;npm&lt;/code&gt; 客户端把依赖安装到 &lt;code&gt;node_modules&lt;/code&gt; 目录的过程具有不确定性。这意味着当依赖的安装顺序不同时，&lt;code&gt;node_modules&lt;/code&gt; 目录的结构可能会发生变化。这种差异可能会导致类似&lt;font color=&quot;red&quot;&gt;“我的电脑上可以运行，别的电脑上不行”&lt;/font&gt;的情况，并且通常需要花费大量时间定为与解决。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有时候就会遇到这种情况，完整可运行的项目上传到 git 上，别人 pull 下来以后，npm install 会报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yarnpkg/yarn&quot;&gt;Yarn&lt;/a&gt; 一开始的主要目标是解决由于语义版本控制而导致的 npm 安装的不确定性问题。虽然可以用 &lt;code&gt;npm shrinkwrap&lt;/code&gt; 来实现可预测的依赖关系树，但它并不是默认选项，而是取决于所有的开发人员指导并启用这个选项。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Yarn" scheme="https://neveryu.github.io/tags/Yarn/"/>
    
  </entry>
  
  <entry>
    <title>Vue 服务端渲染 or 预渲染</title>
    <link href="https://neveryu.github.io/2018/vue-prerender/"/>
    <id>https://neveryu.github.io/2018/vue-prerender/</id>
    <published>2018-06-18T08:25:24.000Z</published>
    <updated>2018-06-19T15:27:03.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>关于 Vue 的 SPA 说的已经太多太多了，它为我们带来了极速的开发体验，极强的开发效率。可能唯一有些许不足的就是，当我们对 SEO 很在乎的时候，我们如何去处理 SEO 的需求。</p><p>关于 SEO ，Vue 也有现成的解决方案： <a href="https://ssr.vuejs.org/zh/" target="_blank" rel="external">Vue 服务端渲染</a></p><a id="more"></a><h2 id="那么"><a href="#那么" class="headerlink" title="那么"></a>那么</h2><h3 id="什么是服务端渲染"><a href="#什么是服务端渲染" class="headerlink" title="什么是服务端渲染"></a>什么是服务端渲染</h3><p>服务端将完整的页面 html 输出到客户端显示，与 SPA （Single-Page-Application）使用 js 渲染页面不同。</p><h3 id="为什么使用服务端渲染"><a href="#为什么使用服务端渲染" class="headerlink" title="为什么使用服务端渲染"></a>为什么使用服务端渲染</h3><ul><li>更好的 SEO</li><li>更快的内容到达时间</li></ul><h3 id="服务端渲染-or-预渲染"><a href="#服务端渲染-or-预渲染" class="headerlink" title="服务端渲染 or 预渲染"></a>服务端渲染 or 预渲染</h3><p>就像官网所说的，如果你调研服务器端渲染(SSR)只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要<a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="external">预渲染</a>，一个典型的预渲染使用场景可能类似<a href="https://neveryu.github.io/vue-tour/">这个网站</a>。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><strong>服务端渲染</strong>和<strong>预渲染</strong>的使用场景还是有较明显的区别的。预渲染的使用场景更多是我们所说的静态页面的形式，比如说<a href="https://neveryu.github.io/vue-tour/">这个网站</a>。服务端渲染适用于大型的、页面数据处理较多且较为复杂的、与服务端有数据交互的功能型网站，一个明显的使用场景就是电商网站。</p><h2 id="如何使用预渲染"><a href="#如何使用预渲染" class="headerlink" title="如何使用预渲染"></a>如何使用预渲染</h2><p><strong>预渲染</strong>的核心是使用 <a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="external">prerender-spa-plugin</a>，如何使用它呢？我们还是以<a href="https://neveryu.github.io/vue-tour/">这个网站</a>的<a href="https://github.com/Neveryu/prerender-website" target="_blank" rel="external">源代码</a>中的 webpack 配置为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">  staticDir: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  routes: [ <span class="string">'/'</span>, <span class="string">'/home'</span>, <span class="string">'/infomation'</span>, <span class="string">'/ticket'</span>, <span class="string">'/scenery'</span>, <span class="string">'/about'</span> ],</span><br><span class="line">  renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">    headless: <span class="literal">false</span>,</span><br><span class="line">    renderAfterDocumentEvent: <span class="string">'render-event'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></p><p>我们需要简单的配置一下，项目所有的路由，最终生成后有几个页面，都是以这个配置为依据，而不是你在 vue-router 中配置的路由。</p><p>最基础也最核心的配置项也就这几行代码，当然，如果你有更多的需求配置项，你可以去 github 上查看文档，文档中也有很详细的介绍。 </p><h2 id="如何搭建一个预渲染开发环境"><a href="#如何搭建一个预渲染开发环境" class="headerlink" title="如何搭建一个预渲染开发环境"></a>如何搭建一个预渲染开发环境</h2><p>如果你也想要使用<strong>预渲染</strong>来开发你的网站的话，最简单的方法就是克隆<a href="https://github.com/Neveryu/prerender-website" target="_blank" rel="external">这个项目</a>，然后简单删减以后进行二次开发，整个的开发流程和 Vue 是一模一样的。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>1、相较于 Vue 的模板中大而全的 webpack 配置项，<strong>预渲染</strong>中的 webpack 配置简单小巧，如果你有一些 webpack 的配置需求的话，你可能需要自己动手。</p><p>2、我的<a href="https://github.com/Neveryu/prerender-website" target="_blank" rel="external">这个项目</a>使用的是 stylus 来作为 css 预编译语言，如果你想使用其他的 css 预编译语言的话，需要额外安装一些插件以及做一些简单配置。当然了，默认的 css 肯定是支持的。</p><p>3、在写这个项目的过程中，也有做一些简单的知识点记录。<a href="https://github.com/Neveryu/prerender-website/blob/master/project-note.md" target="_blank" rel="external">vue-prerender 笔记</a></p><p>4、最后项目打包发布到生产环境，使用 <code>npm run build</code> 一键操作即可。如果你想要部署到子目录下的话，那么，你可能需要做一些简单的修改，具体在 <a href="https://github.com/Neveryu/prerender-website/blob/master/project-note.md" target="_blank" rel="external">vue-prerender 笔记</a> 有提到。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p><a href="https://neveryu.github.io/vue-tour/">项目预览</a><br><a href="https://github.com/Neveryu/prerender-website" target="_blank" rel="external">项目github地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;关于 Vue 的 SPA 说的已经太多太多了，它为我们带来了极速的开发体验，极强的开发效率。可能唯一有些许不足的就是，当我们对 SEO 很在乎的时候，我们如何去处理 SEO 的需求。&lt;/p&gt;
&lt;p&gt;关于 SEO ，Vue 也有现成的解决方案： &lt;a href=&quot;https://ssr.vuejs.org/zh/&quot;&gt;Vue 服务端渲染&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://neveryu.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>关于 JavaScript 中 this 的详细总结</title>
    <link href="https://neveryu.github.io/2018/js-this/"/>
    <id>https://neveryu.github.io/2018/js-this/</id>
    <published>2018-05-31T19:25:24.000Z</published>
    <updated>2018-06-17T09:27:00.105Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-blue">在 JavaScript 中，函数中的 this 指向，很多同学总是理不清楚【这必然会带来一些问题】。确实，JavaScript 中，函数的 this 指向比较复杂多变。它和你调用的方式有关系，和 <strong>严格模式</strong> 或者 <strong>非严格模式</strong> 有关系，和你是否使用了箭头函数有关系，和你在使用函数时是否传入了 this 有关系，和你是否主动修改了调用对象有关系。</p><ul><li>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值。<code>this</code> 不能再执行期间被赋值，并且在每次函数被调用时 <code>this</code> 的值也可能会不同。<code>ES5</code> 引入了 <code>bind</code> 方法来设置函数的 <code>this</code> 值，<a href="https://blog.csdn.net/csdn_yudong/article/details/78730844" target="_blank" rel="external">关于bind和call可以看我的文章</a>，而不用考虑函数如何被调用的，<code>ES2015</code> 引入了支持 <code>this</code> 词法解析的箭头函数（它在闭合的执行上下文内设置 <code>this</code> 的值）。</li></ul><ul><li>与其他语言相比，<strong>函数的 <code>this</code> 关键字</strong>在 <code>JavaScript</code> 中的表现略有不同，此外，在 严格模式 和 非严格模式之间也会有一些差别。</li></ul><a id="more"></a><h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）<code>this</code> 都指代全局对象。【在全局执行上下文中 <code>this</code> 都是全局对象 <code>window</code>】（浏览器环境）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);    <span class="comment">// window</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a);  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);    <span class="comment">// window</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.b);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数内部，<code>this</code> 的值取决于函数被调用的方式。【取决于被调用的方式】</p><h3 id="简单调用"><a href="#简单调用" class="headerlink" title="简单调用"></a>简单调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line">f1() === <span class="built_in">window</span>;  <span class="comment">// 在浏览器中，全局对象是widnow</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Node 中</span></span><br><span class="line">f1() === global;</span><br></pre></td></tr></table></figure><p>【在严格模式下，<code>this</code> 将保持他进入执行上下文时的值】</p><p>在严格模式下，<code>this</code> 将保持他进入执行上下文时的值，所以下面的 <code>this</code> 将会默认为 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>; <span class="comment">// 这里是严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">f2() === <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以，在严格模式下，如果 <code>this</code> 没有被执行上下文（execution context）定义，那它将保持为 <code>undefined</code>。</p><p>因为 <code>f2()</code> 是被直接调用的，而不是作为对象的属性或方法调用的（如<code>window.f2()</code>）。有一些浏览器最初在支持严格模式时没有正确实现这个功能，于是它们错误的返回了 <code>window</code> 对象。</p><p>但是，如果用 <code>window</code> 来调用的话，<code>this</code> 就是 <code>window</code> 了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>; <span class="comment">// 这里是严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.f2())  <span class="comment">// window</span></span><br></pre></td></tr></table></figure></p><p>如果要想把 <code>this</code> 的值从一个上下文传到另一个，就要用 <code>call</code> 或者 <code>apply</code> 方法。</p><p>当一个函数在其主体中使用 <code>this</code> 关键字时，可以通过使用函数继承自 <code>Function.prototype</code> 的 <code>call</code> 或 <code>apply</code> 方法将 <code>this</code> 值绑定到调用中的特定对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是作为‘this’使用的对象</span></span><br><span class="line"><span class="comment">// 后续参数作为参数传递给函数调用</span></span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 1 + 3 + 5 + 7 = 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数也是作为‘this’使用的对象</span></span><br><span class="line"><span class="comment">// 第二个参数是一个数组，数组里的元素用作函数调用中的参数</span></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 1 + 3 + 10 + 20 = 34</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>call</code> 和 <code>apply</code> 函数的时候要注意，如果传递给 <code>this</code> 的值不是一个对象，<code>JavaScript</code> 会尝试使用内部 <code>ToObject</code> 操作将其转换为对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因此，如果传递的值是一个原始值比如 <span class="number">7</span> 或 <span class="string">'foo'</span>，那么就会使用相关构造函数将它转换为对象，所以原始值 <span class="number">7</span> 会被转为对象，像 </span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">7</span>) 这样，而字符串 <span class="string">'foo'</span> 转化成 <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'foo'</span>) 这样。</span><br></pre></td></tr></table></figure><h2 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h2><p><code>ECMAScript 5</code> 引入了 <code>Function.prototype.bind</code>。调用 <code>f.bind(someObject)</code> 会 <strong>创建</strong>一个与 <code>f</code> 具有相同函数体和作用域的函数，但是在这个新函数中，<code>this</code> 将永久地被绑定到了 <code>bind</code> 的第一个参数，无论这个函数是如何被调用的。</p><p>【<code>this</code> 将永久的被绑定到了 <code>bind</code> 的第一个参数，无论这个函数是如何被调用的】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">a</span>:<span class="string">"azerty"</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// azerty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h = g.bind(&#123;<span class="attr">a</span>:<span class="string">'yoo'</span>&#125;); <span class="comment">// bind只生效一次！</span></span><br><span class="line"><span class="built_in">console</span>.log(h()); <span class="comment">// azerty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">37</span>, <span class="attr">f</span>:f, <span class="attr">g</span>:g, <span class="attr">h</span>:h&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.f(), o.g(), o.h()); <span class="comment">// 37, azerty, azerty</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>在箭头函数中，<code>this</code> 与封闭词法上下文的 <code>this</code> 保持一致。在全局代码中，它将被设置为全局对象。【封闭词法上下文 是什么意思，你知道吗？】<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着上面的代码</span></span><br><span class="line"><span class="comment">// 作为对象的一个方法调用</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>: foo&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.foo() === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试使用call来设定this</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.call(obj) === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试使用bind来设定this</span></span><br><span class="line">foo = foo.bind(obj);</span><br><span class="line"><span class="built_in">console</span>.log(foo() === <span class="built_in">window</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>【无论如何，<code>foo</code> 的 <code>this</code> 被设置为<strong>他被创建时的上下文</strong>（在上面的例子中，就是全局对象）】<br>这同样适用于在其他函数内创建的箭头函数：这些箭头函数的 <code>this</code> 被设置为封闭的词法上下文的。</p><h2 id="作为对象的方法"><a href="#作为对象的方法" class="headerlink" title="作为对象的方法"></a>作为对象的方法</h2><blockquote><p>当函数作为对象里的方法被调用时，它们的 <code>this</code> 是调用该函数的对象</p></blockquote><p><code>this</code> 的绑定只受最靠近的成员引用的影响。在下面的例子中，我们把一个方法 <code>g</code> 当做对象 <code>o.b</code> 的函数调用。在这次执行期间，函数中的 <code>this</code> 将指向 <code>o.b</code> 。事实证明，这与他是对象 <code>o</code> 的成员没有多大关系，最靠近的引用才是最重要的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o.b = &#123; <span class="attr">g</span>: independent, <span class="attr">prop</span>: <span class="number">42</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(o.b.g())</span><br></pre></td></tr></table></figure></p><h2 id="原型链中的-this"><a href="#原型链中的-this" class="headerlink" title="原型链中的 this"></a>原型链中的 <code>this</code></h2><p>对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么 <code>this</code> 指向的是调用这个方法的对象，就像该方法在对象上一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.f()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>在这个例子中，对象 <code>p</code> 没有属于它自己的 <code>f</code> 属性，它的 <code>f</code> 属性继承自它的原型。虽然在对 <code>f</code> 的查找过程中，最终是在 <code>o</code> 中找到 <code>f</code> 属性的，这并没有关系；查找过程首先从 <code>p.f</code> 的引用开始，所以函数中的 <code>this</code> 指向 <code>p</code>。也就是说，因为 <code>f</code> 是作为 <code>p</code> 的方法调用的，所以它的 <code>this</code> 指向了 <code>p</code> 。这是 <code>JavaScript</code> 的原型继承中的一个有趣的特性。</p><h2 id="作为构造函数"><a href="#作为构造函数" class="headerlink" title="作为构造函数"></a>作为构造函数</h2><p>当一个函数用作构造函数时（适用 <code>new</code> 关键字），它的 <code>this</code> 被绑定到正在构造的新对象。</p><p>虽然构造器返回的默认值是 <code>this</code> 所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回 <code>this</code> 对象）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造函数这样工作:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * function MyConstructor()&#123;</span></span><br><span class="line"><span class="comment"> *   // 函数实体写在这里</span></span><br><span class="line"><span class="comment"> *   // 根据需要在this上创建属性，然后赋值给它们，比如：</span></span><br><span class="line"><span class="comment"> *   this.fum = "nom";</span></span><br><span class="line"><span class="comment"> *   // 等等...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   // 如果函数具有返回对象的return语句，</span></span><br><span class="line"><span class="comment"> *   // 则该对象将是 new 表达式的结果。 </span></span><br><span class="line"><span class="comment"> *   // 否则，表达式的结果是当前绑定到 this 的对象。</span></span><br><span class="line"><span class="comment"> *   //（即通常看到的常见情况）。</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">37</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> C();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">37</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">a</span>:<span class="number">38</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> C2();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 38</span></span><br></pre></td></tr></table></figure><p>在刚刚的例子中（C2），因为在调用构造函数的过程中，手动的设置了返回对象，与 <code>this</code> 绑定的默认对象被丢弃了。（这基本上使得语句 <code>this.a = 37;</code> 成了“僵尸”代码，实际上并不是真正的“僵尸”，这条语句执行了，但是对于外部没有任何影响，因此完全可以忽略它）。</p><h2 id="作为一个-DOM-事件处理函数"><a href="#作为一个-DOM-事件处理函数" class="headerlink" title="作为一个 DOM 事件处理函数"></a>作为一个 DOM 事件处理函数</h2><blockquote><p>当函数被用作事件处理函数时，它的 <code>this</code> 指向触发事件的元素（一些浏览器在使用非 <code>addEventListener</code> 的函数动态添加监听函数时不遵守这个约定）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用时，将关联的元素变成蓝色</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bluify</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === e.currentTarget); <span class="comment">// 总是 true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 currentTarget 和 target 是同一个对象时为 true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === e.target);        </span><br><span class="line">  <span class="keyword">this</span>.style.backgroundColor = <span class="string">'#A5D9F3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文档中的所有元素的列表</span></span><br><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;elements.length ; i++)&#123;</span><br><span class="line">  elements[i].addEventListener(<span class="string">'click'</span>, bluify, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="作为一个内联事件处理函数"><a href="#作为一个内联事件处理函数" class="headerlink" title="作为一个内联事件处理函数"></a>作为一个内联事件处理函数</h2><blockquote><p>当代码被内联 <code>on-event</code> 处理函数 调用时，它的 <code>this</code> 指向监听器所在的 <code>DOM</code> 元素</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert(this.tagName.toLowerCase());"</span>&gt;</span></span><br><span class="line">  Show this</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的 <code>alert</code> 会显示 <code>button</code> 。注意只有外层代码中的 <code>this</code> 是这样设置的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert((function()&#123;return this&#125;)());"</span>&gt;</span></span><br><span class="line">  Show inner this</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这种情况下，没有设置内部函数的 <code>this</code>，所以它指向 <code>global/window</code> 对象（即非严格模式下调用的函数未设置 <code>this</code> 时指向的默认对象）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-blue&quot;&gt;在 JavaScript 中，函数中的 this 指向，很多同学总是理不清楚【这必然会带来一些问题】。确实，JavaScript 中，函数的 this 指向比较复杂多变。它和你调用的方式有关系，和 &lt;strong&gt;严格模式&lt;/strong&gt; 或者 &lt;strong&gt;非严格模式&lt;/strong&gt; 有关系，和你是否使用了箭头函数有关系，和你在使用函数时是否传入了 this 有关系，和你是否主动修改了调用对象有关系。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在绝大多数情况下，函数的调用方式决定了 &lt;code&gt;this&lt;/code&gt; 的值。&lt;code&gt;this&lt;/code&gt; 不能再执行期间被赋值，并且在每次函数被调用时 &lt;code&gt;this&lt;/code&gt; 的值也可能会不同。&lt;code&gt;ES5&lt;/code&gt; 引入了 &lt;code&gt;bind&lt;/code&gt; 方法来设置函数的 &lt;code&gt;this&lt;/code&gt; 值，&lt;a href=&quot;https://blog.csdn.net/csdn_yudong/article/details/78730844&quot;&gt;关于bind和call可以看我的文章&lt;/a&gt;，而不用考虑函数如何被调用的，&lt;code&gt;ES2015&lt;/code&gt; 引入了支持 &lt;code&gt;this&lt;/code&gt; 词法解析的箭头函数（它在闭合的执行上下文内设置 &lt;code&gt;this&lt;/code&gt; 的值）。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;与其他语言相比，&lt;strong&gt;函数的 &lt;code&gt;this&lt;/code&gt; 关键字&lt;/strong&gt;在 &lt;code&gt;JavaScript&lt;/code&gt; 中的表现略有不同，此外，在 严格模式 和 非严格模式之间也会有一些差别。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://neveryu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue2.x 做一个音乐app</title>
    <link href="https://neveryu.github.io/2018/vue-music/"/>
    <id>https://neveryu.github.io/2018/vue-music/</id>
    <published>2018-04-30T19:25:24.000Z</published>
    <updated>2023-04-04T08:42:15.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p id="div-border-top-green">本项目是基于 vue2.4.1 最新的实战项目，vue-cli2.9.3 + vue2.4.1 + axios + vue-router3.0.1 + es6 + vux3.0.1 + webpack + better-scroll + 线上真实接口的一个移动端音乐 app。</p><a id="more"></a><p><img src="/images/vue-music-2.png" alt></p><h2 id="实现的功能"><a href="#实现的功能" class="headerlink" title="实现的功能"></a>实现的功能</h2><p>1、音乐列表、歌单、歌手、排行、榜单、推荐<br>2、音乐播放、暂停、上一曲、下一曲、喜欢<br>3、播放列表、添加到播放列表、历史列表<br>4、搜索单曲、歌手、专辑、MV<br>5、查看歌手页面、专辑页面、MV<br>6、热门搜索<br>7、搜索历史记录<br>8、排行榜<br>9、切换播放模式<br>10、歌词<br>11、个人中心<br>12、项目介绍</p><p id="div-border-left-red">现在最流行的开发方式就是前后分离了；<br><a href="/tags/vue">vue</a> 也是现在最流行的前端框架之一。</p><h2 id="截屏演示"><a href="#截屏演示" class="headerlink" title="截屏演示"></a>截屏演示</h2><video src="/images/vue-music.mp4" controls="controls" preload="preload" height="400px"></video><h2 id="移动端演示"><a href="#移动端演示" class="headerlink" title="移动端演示"></a>移动端演示</h2><p>扫二维码在手机上查看效果更好<br><img src="/images/vue-music-1.png" alt></p><h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2><p><a href="https://github.com/Neveryu/vue-music" target="_blank" rel="external">https://github.com/Neveryu/vue-music</a></p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install dependencies</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># serve with hot reload at localhost:8080</span></span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># build for production with minification</span></span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># build for production and view the bundle analyzer report</span></span><br><span class="line">npm run build --report</span><br><span class="line"></span><br><span class="line"><span class="comment"># run local server</span></span><br><span class="line">npm run prod.server.js</span><br></pre></td></tr></table></figure><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 npm install 长时间没有反应或者安装失败，请尝试</span></span><br><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><p>vue 有自己的脚手架构建工具 vue-cli 。使用起来非常方便，使用 webpack 来集成各种开发便捷工具，比如：</p><ul><li>代码热更新，修改代码之后网页无刷新改变，对前端开发来说非常的方便</li><li>Postcss，再也不用去管兼容性的问题了，只针对 chrome 写 css 代码，会自动编译生成支持多款浏览器的 css 代码</li><li>ESlint，统一代码风格</li><li>bable，ES2015 出来已经有一段事件了，但是不少浏览器还没有兼容 ES6。有了 bable，放心使用 ES6 语法，它会自动转义成 ES5 语法</li><li>Stylus，类似于 sass/scss ，但是可以不写 <code>{ }</code> 和 <code>:</code>，使用起来还是很方便的</li><li>better-scroll，很好用的移动端各种滚动场景需求的插件（已支持PC）</li><li>vuex，Vuex是一个专为 Vue.js 应用程序开发的状态管理模式</li><li>vue-router，专为 Vue.js 应用程序开发的路由工具</li></ul><p>除此之外，vue-cli 已经使用 node 配置了一套本地服务器和安装命令等，本地运行和打包只需要一个命令就可以搞定，非常的方便。</p><h2 id="为什么写这个项目"><a href="#为什么写这个项目" class="headerlink" title="为什么写这个项目"></a>为什么写这个项目</h2><p>之前的 <a href="/2017/vue-sell/">vue-sell</a>，是一个非常好的 vue 的项目教程了，学了 vue 以后，跟着做一遍 vue-sell，应该对 vue 的基本操作都能非常熟练的掌握了。<br>但是如何结合 vuex 和 vue-router，以及其他技术，做一个大型的项目，很多同学还是苦于没有经验和项目实例，所以就有了这个 vue-music。</p><p><a href="https://neveryu.github.io/vue-music/">vue-music</a> 里面用到了 vue 全家桶，还有 better-scroll，jsonp 等其他工具，用的也是线上真实的音乐接口数据，而且项目里封装了很多完美的组件，对个人技术的学习和提升有很大的帮助，项目级别上也达到了中大型级别。<br>非常适合 vue 的进阶学习。</p><h2 id="获取教程"><a href="#获取教程" class="headerlink" title="获取教程"></a>获取教程</h2><p>这个项目我从头到尾写了一遍，解决了项目中遇到的所有问题，由于有一些包或者模块升级的原因，会有一些小的问题，我都已经解决过了。想获取教程或者有疑问的，可以加这个群。</p><font color="#f69" size="5">建了一个qq群，可以点击这个logo<a target="_blank" href="//shang.qq.com/wpa/qunwpa?idkey=32da7a18744756b0d8ffdd05b84999afecb5265dbad0fb119033e122abe803f3"><img border="0" width="150" src="https://neveryu.github.io/vue-tour/logo1.png" alt="Vue学习交流" title="Vue学习交流" style="vertical-align: middle"></a>，或者手动search群号：<a target="_blank" href="//shang.qq.com/wpa/qunwpa?idkey=32da7a18744756b0d8ffdd05b84999afecb5265dbad0fb119033e122abe803f3">685486827</a></font>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p id=&quot;div-border-top-green&quot;&gt;本项目是基于 vue2.4.1 最新的实战项目，vue-cli2.9.3 + vue2.4.1 + axios + vue-router3.0.1 + es6 + vux3.0.1 + webpack + better-scroll + 线上真实接口的一个移动端音乐 app。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://neveryu.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue2.x 做一个外卖app</title>
    <link href="https://neveryu.github.io/2017/vue-sell/"/>
    <id>https://neveryu.github.io/2017/vue-sell/</id>
    <published>2017-11-10T19:25:24.000Z</published>
    <updated>2018-10-16T07:41:18.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p id="div-border-top-green">本项目是基于 vue2.4 最新的实战项目，vue-cli2.8 + vue2.4 + vue-resource + vue-router2.7 + es6 + mock + webpack 的一个移动端外卖 app。</p><p><img src="/images/vue-sell-1.png" alt></p><p id="div-border-left-red">现在最流行的开发方式就是前后分离了；<br><a href="/tags/vue">vue</a> 也是现在最流行的前端框架之一。</p><a id="more"></a><h2 id="截屏演示"><a href="#截屏演示" class="headerlink" title="截屏演示"></a>截屏演示</h2><p><img src="/images/vue-sell-3.gif" alt></p><h2 id="移动端演示"><a href="#移动端演示" class="headerlink" title="移动端演示"></a>移动端演示</h2><p>扫二维码在手机上查看效果更好<br><img src="/images/vue-sell-2.png" alt></p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>vue 有自己的脚手架构建工具 vue-cli 。使用起来非常方便，使用 webpack 来集成各种开发便捷工具，比如：</p><ul><li>代码热更新，修改代码之后网页无刷新改变，对前端开发来说非常的方便</li><li>Postcss，再也不用去管兼容性的问题了，只针对 chrome 写 css 代码，会自动编译生成支持多款浏览器的 css 代码</li><li>ESlint，统一代码风格</li><li>bable，ES2015 出来已经有一段事件了，但是不少浏览器还没有兼容 ES6。有了 bable，放心使用 ES6 语法，它会自动转义成 ES5 语法</li><li>Stylus，类似于 sass/scss ，但是可以不写 <code>{ }</code> 和 <code>:</code>，使用起来还是很方便的</li></ul><p>除此之外，vue-cli 已经使用 node 配置了一套本地服务器和安装命令等，本地运行和打包只需要一个命令就可以搞定，非常的方便。</p><h2 id="为什么写这个项目"><a href="#为什么写这个项目" class="headerlink" title="为什么写这个项目"></a>为什么写这个项目</h2><p>vue 的官网文档写的很好，很多同学在学习完文档以后，很难实际上手做项目，只能做一些 todo-list 的小 demo ,距离上手做项目还有一些差距。<br>这一套 vue 的实战视频可以说是非常适合新手入门进阶，让你可以动手用 vue 来做项目，解决 vue 在实战中的问题才是大家最想学习的，而不是小打小闹的 demo。<br><img src="/images/vue-sell-5.png" alt></p><p>而且这套视频教程包含现在最新的前端必备技术点详细教学：webpack、eslint、vue-cli构建、模块打包、mock、vue-resource、axios、以及真实项目中会遇到的各种问题以及解决方案。</p><h2 id="获取教程"><a href="#获取教程" class="headerlink" title="获取教程"></a>获取教程</h2><p>这个项目我从头到尾写了一遍，由于有一些包或者模块升级的原因，会有一些小的问题，我都已经解决过了。想获取教程或者有疑问的，可以加这个群。</p><font color="#f69" size="5">建了一个qq群，可以点击这个logo<a target="_blank" href="//shang.qq.com/wpa/qunwpa?idkey=32da7a18744756b0d8ffdd05b84999afecb5265dbad0fb119033e122abe803f3"><img border="0" width="150" src="https://neveryu.github.io/vue-tour/logo1.png" alt="Vue学习交流" title="Vue学习交流" style="vertical-align: middle"></a>，或者手动search群号：<a target="_blank" href="//shang.qq.com/wpa/qunwpa?idkey=32da7a18744756b0d8ffdd05b84999afecb5265dbad0fb119033e122abe803f3">685486827</a></font>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p id=&quot;div-border-top-green&quot;&gt;本项目是基于 vue2.4 最新的实战项目，vue-cli2.8 + vue2.4 + vue-resource + vue-router2.7 + es6 + mock + webpack 的一个移动端外卖 app。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/vue-sell-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p id=&quot;div-border-left-red&quot;&gt;现在最流行的开发方式就是前后分离了；&lt;br&gt;&lt;a href=&quot;/tags/vue&quot;&gt;vue&lt;/a&gt; 也是现在最流行的前端框架之一。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://neveryu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://neveryu.github.io/tags/vue/"/>
    
  </entry>
  
</feed>
