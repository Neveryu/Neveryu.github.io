<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>流动的虚线 ｜ 仿车辆导航效果</title>
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link
      rel="shortcut icon"
      href="../../files/favicon_white.ico"
      media="(prefers-color-scheme: dark)"
    />
    <link
      rel="shortcut icon"
      href="../../files/favicon.ico"
      media="(prefers-color-scheme: light)"
    />
    <link rel="stylesheet" type="text/css" href="./css/main.css" />
    <style></style>
  </head>

  <body>
    <div id="viewer" name="viewer" allow="fullscreen; xr-spatial-tracking;">
      <div id="container"></div>
    </div>
    <div id="desc">
      <p>通过改变LineDashedMaterial材质的scale属性来实现</p>
      <p>而不是改变dashOffset属性</p>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "../three/build/three.module.js",
          "three/addons/": "../three/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import Stats from "three/addons/libs/stats.module.js";
      import TWEEN from "three/addons/libs/tween.module.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      let scene, renderer, camera, stats, material;

      init();
      initStats();

      /**
       * Initialize the statistics domelement
       *
       * @param {Number} type 0: fps, 1: ms, 2: mb, 3+: custom
       * @returns stats javascript object
       */
      function initStats(type) {
        var panelType =
          typeof type !== "undefined" && type && !isNaN(type)
            ? parseInt(type)
            : 0;
        stats = new Stats();
        stats.showPanel(panelType); // 0: fps, 1: ms, 2: mb, 3+: custom
        document.body.appendChild(stats.dom);
      }

      function init() {
        const container = document.getElementById("container");

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );
        camera.position.set(10, 10, 20);
        camera.lookAt(0, 0, 0);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xa0a0a0);
        // scene.fog = new THREE.Fog(0xa0a0a0, 10, 50);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
        hemiLight.position.set(0, 100, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff);
        dirLight.position.set(-3, 100, -10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 2;
        dirLight.shadow.camera.bottom = -2;
        dirLight.shadow.camera.left = -2;
        dirLight.shadow.camera.right = 2;
        dirLight.shadow.camera.near = 0.1;
        dirLight.shadow.camera.far = 40;
        scene.add(dirLight);

        /**
         * 开启抗锯齿（antialias: true）可以平滑渲染结果中的边缘，减少锯齿状现象，使图形看起来更加平滑和真实。
         * 开启抗锯齿会增加渲染负担，可能导致渲染性能下降，特别是在低端设备上。因此，在需要高性能渲染的场景中，可能需要权衡抗锯齿效果和性能。
         **/
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.update();
        // listeners
        window.addEventListener("resize", onWindowResize);
      }

      // 实时渲染
      function animate() {
        stats.update();
        requestAnimationFrame(animate);

        material.scale += 0.02;
        // 调试输出（可选）
        // console.log(material);
        // if (material.dashOffset < 0) {
        //   material.dashOffset = material.dashSize;
        // }
        renderer.render(scene, camera);
      }

      function onWindowResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }

      // 创建材质
      material = new THREE.LineDashedMaterial({
        color: 0x00ff00,
        dashSize: 8,
        gapSize: 4,
        linewidth: 2,
        scale: 1,
      });

      // 定义线条的路径（例如，一个简单的曲线）
      const points = [];
      for (let i = 0; i < 20; i++) {
        points.push(new THREE.Vector3(i, Math.sin(i * 0.5) * 2, 0)); // 创建一个波浪形路径
      }

      const geometry = new THREE.BufferGeometry().setFromPoints(points);

      // 创建线条
      var line = new THREE.Line(geometry, material);
      line.position.x = -10;

      // 要用line.computeLineDistances()才能出现虚线
      line.computeLineDistances();

      scene.add(line);

      animate();
    </script>
  </body>
</html>
